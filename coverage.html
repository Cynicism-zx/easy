
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>alipay: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/weblazy/easy/pkg/alipay/alipay.go (0.0%)</option>
				
				<option value="file1">github.com/weblazy/easy/pkg/wx/wx.go (0.0%)</option>
				
				<option value="file2">github.com/weblazy/easy/utils/bitmap/bitmap.go (0.0%)</option>
				
				<option value="file3">github.com/weblazy/easy/utils/cache/cache.go (85.3%)</option>
				
				<option value="file4">github.com/weblazy/easy/utils/csvx/csvx.go (0.0%)</option>
				
				<option value="file5">github.com/weblazy/easy/utils/errorx/atomicerror.go (100.0%)</option>
				
				<option value="file6">github.com/weblazy/easy/utils/errorx/batcherror.go (100.0%)</option>
				
				<option value="file7">github.com/weblazy/easy/utils/filex/filex.go (76.5%)</option>
				
				<option value="file8">github.com/weblazy/easy/utils/gpool/gpool.go (0.0%)</option>
				
				<option value="file9">github.com/weblazy/easy/utils/httpx/http.go (0.0%)</option>
				
				<option value="file10">github.com/weblazy/easy/utils/httpx/httpx.go (0.0%)</option>
				
				<option value="file11">github.com/weblazy/easy/utils/httpx/ip.go (0.0%)</option>
				
				<option value="file12">github.com/weblazy/easy/utils/httpx/log.go (0.0%)</option>
				
				<option value="file13">github.com/weblazy/easy/utils/lang/lang.go (50.0%)</option>
				
				<option value="file14">github.com/weblazy/easy/utils/list/list.go (48.1%)</option>
				
				<option value="file15">github.com/weblazy/easy/utils/logx/logx.go (55.6%)</option>
				
				<option value="file16">github.com/weblazy/easy/utils/mapreduce/mapreduce.go (99.0%)</option>
				
				<option value="file17">github.com/weblazy/easy/utils/mapx/mapx.go (0.0%)</option>
				
				<option value="file18">github.com/weblazy/easy/utils/monitor/dingtalk.go (0.0%)</option>
				
				<option value="file19">github.com/weblazy/easy/utils/monitor/monitor.go (0.0%)</option>
				
				<option value="file20">github.com/weblazy/easy/utils/sortx/sort.go (0.0%)</option>
				
				<option value="file21">github.com/weblazy/easy/utils/sqlx/sqlx.go (0.0%)</option>
				
				<option value="file22">github.com/weblazy/easy/utils/stringx/stringx.go (0.0%)</option>
				
				<option value="file23">github.com/weblazy/easy/utils/syncx/atomicbool.go (100.0%)</option>
				
				<option value="file24">github.com/weblazy/easy/utils/syncx/atomicduration.go (100.0%)</option>
				
				<option value="file25">github.com/weblazy/easy/utils/syncx/atomicfloat64.go (100.0%)</option>
				
				<option value="file26">github.com/weblazy/easy/utils/syncx/concurrentdoublemap.go (0.0%)</option>
				
				<option value="file27">github.com/weblazy/easy/utils/syncx/concurrentmap.go (0.0%)</option>
				
				<option value="file28">github.com/weblazy/easy/utils/syncx/cond.go (100.0%)</option>
				
				<option value="file29">github.com/weblazy/easy/utils/syncx/donechan.go (100.0%)</option>
				
				<option value="file30">github.com/weblazy/easy/utils/syncx/limit.go (100.0%)</option>
				
				<option value="file31">github.com/weblazy/easy/utils/syncx/lockedcalls.go (100.0%)</option>
				
				<option value="file32">github.com/weblazy/easy/utils/syncx/managedresource.go (100.0%)</option>
				
				<option value="file33">github.com/weblazy/easy/utils/syncx/once.go (100.0%)</option>
				
				<option value="file34">github.com/weblazy/easy/utils/syncx/onceguard.go (100.0%)</option>
				
				<option value="file35">github.com/weblazy/easy/utils/syncx/pool.go (100.0%)</option>
				
				<option value="file36">github.com/weblazy/easy/utils/syncx/refresource.go (100.0%)</option>
				
				<option value="file37">github.com/weblazy/easy/utils/syncx/resourcemanager.go (100.0%)</option>
				
				<option value="file38">github.com/weblazy/easy/utils/syncx/sharedcalls.go (100.0%)</option>
				
				<option value="file39">github.com/weblazy/easy/utils/syncx/spinlock.go (100.0%)</option>
				
				<option value="file40">github.com/weblazy/easy/utils/syncx/timeoutlimit.go (93.3%)</option>
				
				<option value="file41">github.com/weblazy/easy/utils/system/shutdown.go (0.0%)</option>
				
				<option value="file42">github.com/weblazy/easy/utils/system/signals.go (60.0%)</option>
				
				<option value="file43">github.com/weblazy/easy/utils/threading/rescue.go (100.0%)</option>
				
				<option value="file44">github.com/weblazy/easy/utils/threading/routinegroup.go (100.0%)</option>
				
				<option value="file45">github.com/weblazy/easy/utils/threading/routines.go (100.0%)</option>
				
				<option value="file46">github.com/weblazy/easy/utils/threading/taskrunner.go (100.0%)</option>
				
				<option value="file47">github.com/weblazy/easy/utils/threading/timeout.go (100.0%)</option>
				
				<option value="file48">github.com/weblazy/easy/utils/timex/relativetime.go (100.0%)</option>
				
				<option value="file49">github.com/weblazy/easy/utils/timex/ticker.go (90.0%)</option>
				
				<option value="file50">github.com/weblazy/easy/utils/timex/timex.go (0.0%)</option>
				
				<option value="file51">github.com/weblazy/easy/utils/timex/utils.go (0.0%)</option>
				
				<option value="file52">github.com/weblazy/easy/utils/timingwheel/timingwheel.go (41.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package alipay

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/weblazy/easy/utils/httpx"

        "github.com/weblazy/gocore/httplib"
        "gopkg.in/redis.v5"
)

type (
        Alipay struct {
                appId              string
                rsaPrivateKey      string
                alipayrsaPublicKey string
                signType           string
                format             string
                postCharset        string
                apiVersion         string
                getRedis           func() *redis.Client
        }

        GetUserInfoResponse struct {
                Scene     string `json:"scene"`
                Page      string `json:"page"`
                AutoColor bool   `json:"auto_color"`
                IsHyaline bool   `json:"is_hyaline"`
                Width     int64  `json:"width"`
        }
)

const (
        //网关
        gatewayUrl = "https://openapi.alipay.com/gateway.do"
        TimeLayout = "2006-01-02 15:04:05"
)

// @desc 初始化
// @auth liuguoqiang 2020-02-25
// @param
// @return
func NewAlipay(appId, rsaPrivateKey, alipayrsaPublicKey, signType string, getRedis func() *redis.Client) *Alipay <span class="cov0" title="0">{
        return &amp;Alipay{
                appId:              appId,
                rsaPrivateKey:      rsaPrivateKey,
                alipayrsaPublicKey: alipayrsaPublicKey,
                signType:           signType,
                format:             "json",
                postCharset:        "UTF-8",
                apiVersion:         "1.0",
                getRedis:           getRedis,
        }
}</span>

// @desc
// @auth liuguoqiang 2020-04-09
// @param
// @return
func (s *Alipay) GetUserInfo(code string) {<span class="cov0" title="0">

}</span>

// @desc
// @auth liuguoqiang 2020-04-09
// @param
// @return
func (s *Alipay) Request(url, apiParams map[string]interface{}, authToken string, appInfoAuthtoken string) error <span class="cov0" title="0">{
        //组装系统参数
        params := make(map[string]interface{})
        params["app_id"] = s.appId
        params["version"] = s.apiVersion
        params["format"] = s.format
        params["sign_type"] = s.signType
        params["method"] = url
        params["timestamp"] = time.Now().Format(TimeLayout)
        params["auth_token"] = authToken
        params["alipay_sdk"] = "alipay-sdk-php-20180705"
        params["terminal_type"] = nil
        params["terminal_info"] = nil
        params["prod_code"] = nil
        params["notify_url"] = nil
        params["charset"] = s.postCharset
        params["app_auth_token"] = appInfoAuthtoken
        //签名
        params["sign"] = s.generateSign()
        //系统参数放入GET请求串

        requestUrl, err := httpx.MapToQuery(params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">requestUrl = gatewayUrl + "?" + requestUrl
        req := httplib.Post(requestUrl)
        req, err = req.JSONBody(apiParams)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dataByte, err := req.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">data := make(map[string]interface{})
        err = json.Unmarshal(dataByte, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("%#v", data)
        return nil</span>
}

// @desc
// @auth liuguoqiang 2020-04-09
// @param
// @return
func (s *Alipay) generateSign() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package wx

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "strconv"
        "time"

        "github.com/sunmi-OS/gocore/httplib"
        "gopkg.in/redis.v5"
)

type (
        Wx struct {
                appId       string
                secret      string
                grantType   string
                accessToken string
                getRedis    func() *redis.Client
        }

        GetUnLimitQRCodeRequest struct {
                Scene     string `json:"scene"`
                Page      string `json:"page"`
                AutoColor bool   `json:"auto_color"`
                IsHyaline bool   `json:"is_hyaline"`
                Width     int64  `json:"width"`
        }
        SendRequest struct {
                Openid          string `json:"touser"`
                TemplateId      string `json:"template_id"`
                Page            string `json:"page"`
                FormId          string `json:"form_id"`
                Data            string `json:"data"`
                EmphasisKeyword string `json:"emphasis_keyword"`
        }
        DecryptDataRequest struct {
                SessionKey string
                Iv         string
                Data       string
        }
        CheckLoginResponse struct {
                OpenId     string `json:"openId"`
                SessionKey string `json:"session_key"`
        }
)

const (
        // access_token 地址
        AccessTokenUrl = "https://api.weixin.qq.com/cgi-bin/token"
        //获取无限制小程序二维码
        CreateUqrcodeUrl = "https://api.weixin.qq.com/wxa/getwxacodeunlimit"
        //授权$code 访问地址
        CodeAccessUrl    = "https://api.weixin.qq.com/sns/jscode2session"
        TemplatedSendUrl = "https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send"
        //获取授权页ticket
        GetticketUrl = "https://api.weixin.qq.com/cgi-bin/ticket/getticket"
        //获取授权页链接
        AuthUrl = "https://api.weixin.qq.com/card/invoice/getauthurl"
        //上传电子发票PDF文件
        SetpdfUrl = "https://api.weixin.qq.com/card/invoice/platform/setpdf"
        //将电子发票卡券插入用户卡包
        InvoiceInsertUrl = "https://api.weixin.qq.com/card/invoice/insert"
)

// @desc 初始化
// @auth liuguoqiang 2020-02-25
// @param
// @return
func NewWx(appId, secret, grantType string, getRedis func() *redis.Client) *Wx <span class="cov0" title="0">{
        return &amp;Wx{
                appId:     appId,
                secret:    secret,
                grantType: grantType,
                getRedis:  getRedis,
        }
}</span>

// @desc 根据access_token值进行授权
// @auth liuguoqiang 2020-02-25
// @param $isFresh 是否刷新access_token
// @return
func (s *Wx) InitAuthToken(isFresh bool) (string, error) <span class="cov0" title="0">{
        //查询缓存
        tokenKey := "tob_wechat:applet:token:" + s.appId
        accessToken := s.getRedis().Get(tokenKey).Val()

        if accessToken != "" &amp;&amp; !isFresh </span><span class="cov0" title="0">{
                s.accessToken = accessToken
                return s.accessToken, nil
        }</span>

        // 获取token
        <span class="cov0" title="0">req := httplib.Get(AccessTokenUrl + "?grant_type=client_credential&amp;appid=" + s.appId + "&amp;secret=" + s.secret)
        data := make(map[string]interface{})
        err := req.ToJSON(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if accessToken, ok := data["access_token"]; !ok </span><span class="cov0" title="0">{
                return "", errors.New(strconv.FormatFloat(data["errcode"].(float64), 'f', -1, 64) + ":" + data["errmsg"].(string))
        }</span> else<span class="cov0" title="0"> {
                err := s.getRedis().Set(tokenKey, accessToken, 7000*time.Second).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">s.accessToken = accessToken.(string)
                return s.accessToken, nil</span>
        }
}

// @desc 获取二维码
// @auth liuguoqiang 2020-02-25
// @param
// @return
func (s *Wx) GetUnLimitQRCode(params *GetUnLimitQRCodeRequest, isFresh bool) ([]byte, error) <span class="cov0" title="0">{
        return s.Request(nil, params, CreateUqrcodeUrl, isFresh, true)
}</span>

// @desc 发送模板
// @auth liuguoqiang 2020-04-17
// @param
// @return
func (s *Wx) Send(params *SendRequest, isFresh bool) ([]byte, error) <span class="cov0" title="0">{
        return s.Request(nil, params, TemplatedSendUrl, isFresh, true)
}</span>

// @desc 获取授权页面ticket
// @auth liuguoqiang 2020-02-25
// @param
// @return
func (s *Wx) GetTicket(ticketType string, isFresh bool) ([]byte, error) <span class="cov0" title="0">{
        urlParam := make(map[string]string)
        urlParam["type"] = "wx_card"
        return s.Request(urlParam, nil, GetticketUrl, isFresh, false)
}</span>

// @desc 获取微信授权页链接
// @auth liuguoqiang 2020-02-25
// @param
// @return
func (s *Wx) GetAuthUrl(params map[string]interface{}, isFresh bool) ([]byte, error) <span class="cov0" title="0">{
        return s.Request(nil, params, AuthUrl, isFresh, true)
}</span>

// @desc 通用请求
// @auth liuguoqiang 2020-02-25
// @param
// @return
func (s *Wx) Request(urlParam map[string]string, bodyParams interface{}, paramUrl string, isFresh bool, isPost bool) ([]byte, error) <span class="cov0" title="0">{
        if s.accessToken == "" || isFresh </span><span class="cov0" title="0">{
                _, err := s.InitAuthToken(isFresh)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">var req *httplib.BeegoHTTPRequest
        url := paramUrl + "?access_token=" + s.accessToken
        if isPost </span><span class="cov0" title="0">{
                req = httplib.Post(url)
        }</span> else<span class="cov0" title="0"> {
                req = httplib.Get(url)
        }</span>
        <span class="cov0" title="0">if urlParam != nil </span><span class="cov0" title="0">{
                for key, value := range urlParam </span><span class="cov0" title="0">{
                        req = req.Param(key, value)
                }</span>
        }
        <span class="cov0" title="0">req, err := req.JSONBody(bodyParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dataByte, err := req.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">data := make(map[string]interface{})
        err = json.Unmarshal(dataByte, &amp;data)
        if err == nil </span><span class="cov0" title="0">{
                if _, ok := data["errcode"]; ok &amp;&amp; data["errcode"].(float64) != 0 </span><span class="cov0" title="0">{
                        if !isFresh </span><span class="cov0" title="0">{
                                dataByte, err = s.Request(urlParam, bodyParams, paramUrl, true, isPost)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, errors.New(strconv.FormatFloat(data["errcode"].(float64), 'f', -1, 64) + ":" + data["errmsg"].(string))
                        }</span>
                }
        }
        <span class="cov0" title="0">return dataByte, nil</span>
}

// @desc 根据微信code获取授权信息
// @auth liuguoqiang 2020-04-08
// @param
// @return
func (s *Wx) CheckLogin(code string) (*CheckLoginResponse, error) <span class="cov0" title="0">{
        params := make(map[string]interface{})
        params["appid"] = s.appId
        params["secret"] = s.secret
        params["js_code"] = code
        params["grant_type"] = s.grantType
        req := httplib.Post(CodeAccessUrl)
        req, err := req.JSONBody(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dataByte, err := req.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">data := make(map[string]interface{})
        err = json.Unmarshal(dataByte, &amp;data)
        if err == nil </span><span class="cov0" title="0">{
                if _, ok := data["errcode"]; ok </span><span class="cov0" title="0">{
                        return nil, errors.New(strconv.FormatFloat(data["errcode"].(float64), 'f', -1, 64) + ":" + data["errmsg"].(string))
                }</span>
        }
        <span class="cov0" title="0">return &amp;CheckLoginResponse{
                OpenId:     data["openid"].(string),
                SessionKey: data["session_key"].(string),
        }, nil</span>
}

// @desc 检验数据的真实性，并且获取解密后的明文.
// @auth liuguoqiang 2020-04-08
// @param
// @return
func DecryptData(req *DecryptDataRequest) ([]byte, error) <span class="cov0" title="0">{
        if len(req.SessionKey) != 24 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("错误的SessionKey")
        }</span>
        <span class="cov0" title="0">if len(req.Iv) != 24 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("错误的Iv")
        }</span>
        <span class="cov0" title="0">aesKey, err := base64.StdEncoding.DecodeString(req.SessionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">iv, err := base64.StdEncoding.DecodeString(req.Iv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">data, err := base64.StdEncoding.DecodeString(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resp := AesDecrypt(data, aesKey, iv)
        return resp, nil</span>
}

// @desc aes加密
// @auth liuguoqiang 2020-04-21
// @param
// @return
func AesEncrypt(origData []byte, k []byte, iv []byte) string <span class="cov0" title="0">{
        // 分组秘钥
        // NewCipher该函数限制了输入k的长度必须为16, 24或者32
        block, _ := aes.NewCipher(k)
        // 获取秘钥块的长度
        blockSize := block.BlockSize()
        // 补全码
        origData = PKCS7Padding(origData, blockSize)
        // 加密模式
        blockMode := cipher.NewCBCEncrypter(block, iv)
        // 创建数组
        cryted := make([]byte, len(origData))
        // 加密
        blockMode.CryptBlocks(cryted, origData)
        return base64.StdEncoding.EncodeToString(cryted)
}</span>

// @desc aes解密
// @auth liuguoqiang 2020-04-21
// @param
// @return
func AesDecrypt(crytedByte []byte, key []byte, iv []byte) []byte <span class="cov0" title="0">{
        // 分组秘钥
        block, _ := aes.NewCipher(key)
        // 加密模式
        blockMode := cipher.NewCBCDecrypter(block, iv)
        // 创建数组
        orig := make([]byte, len(crytedByte))
        // 解密
        blockMode.CryptBlocks(orig, crytedByte)
        // 去补全码
        orig = PKCS7UnPadding(orig)
        return orig
}</span>

//补码
//AES加密数据块分组长度必须为128bit(byte[16])，密钥长度可以是128bit(byte[16])、192bit(byte[24])、256bit(byte[32])中的任意一个。
// @desc
// @auth liuguoqiang 2020-04-21
// @param
// @return
func PKCS7Padding(ciphertext []byte, blocksize int) []byte <span class="cov0" title="0">{
        padding := blocksize - len(ciphertext)%blocksize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(ciphertext, padtext...)
}</span>

// @desc 去码
// @auth liuguoqiang 2020-04-21
// @param
// @return
func PKCS7UnPadding(origData []byte) []byte <span class="cov0" title="0">{
        length := len(origData)
        unpadding := int(origData[length-1])
        return origData[:(length - unpadding)]
}</span>

// @desc 电子发票插入微信卡包
// @auth liuguoqiang 2020-04-24
// @param
// @return
func (s *Wx) InvoiceInsert(params map[string]interface{}, isFresh bool) ([]byte, error) <span class="cov0" title="0">{
        params["appid"] = s.appId
        return s.Request(nil, params, InvoiceInsertUrl, isFresh, true)
}</span>

// @desc 上传pdf文件
// @auth liuguoqiang 2020-02-25
// @param
// @return
func (s *Wx) SetPdf(pdfPath string, isFresh bool) ([]byte, error) <span class="cov0" title="0">{
        if s.accessToken == "" || isFresh </span><span class="cov0" title="0">{
                _, err := s.InitAuthToken(isFresh)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if pdfPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pdfPath is empty")
        }</span>
        <span class="cov0" title="0">resp, err := http.Get(pdfPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, errors.New("resp status:" + fmt.Sprint(resp.StatusCode))
        }</span>
        <span class="cov0" title="0">bin, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf := new(bytes.Buffer)
        bodyWriter := multipart.NewWriter(buf)
        fileName := fmt.Sprintf("%d.pdf", time.Now().UnixNano()/1000)
        fileWriter, err := bodyWriter.CreateFormFile("pdf", fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, err = fileWriter.Write(bin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyWriter.Close()
        req1, err := http.NewRequest("POST", SetpdfUrl+"?access_token="+s.accessToken, buf)
        req1.Header.Set("Content-Type", bodyWriter.FormDataContentType())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client := http.Client{}
        resp1, err := client.Do(req1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp1.Body.Close()

        dataByte, err := ioutil.ReadAll(resp1.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">data := make(map[string]interface{})
        err = json.Unmarshal(dataByte, &amp;data)
        if err == nil </span><span class="cov0" title="0">{
                if _, ok := data["errcode"]; ok &amp;&amp; data["errcode"].(float64) != 0 </span><span class="cov0" title="0">{
                        if !isFresh </span><span class="cov0" title="0">{
                                dataByte, err = s.SetPdf(pdfPath, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, errors.New(strconv.FormatFloat(data["errcode"].(float64), 'f', -1, 64) + ":" + data["errmsg"].(string))
                        }</span>
                }
        }
        <span class="cov0" title="0">return dataByte, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package bitmap

import (
        "encoding/base64"
        "errors"
        "strings"
        "sync"
)

const (
        bitSize = 8
)

var (
        bitmask     = []byte{1, 1 &lt;&lt; 1, 1 &lt;&lt; 2, 1 &lt;&lt; 3, 1 &lt;&lt; 4, 1 &lt;&lt; 5, 1 &lt;&lt; 6, 1 &lt;&lt; 7}
        outRangeErr = errors.New("num out of range")
)

type bitmap struct {
        bits     []byte // byte字节内容
        count    uint64 // 已填入数字的数量
        byteSize uint64 // 容量byte字节数
        capacity uint64 // 容量bit数
        sync.RWMutex
}

// @desc NewBitmap
// @auth liuguoqiang 2020-12-27
// @param
// @return
func NewBitmap(maxNum uint64) *bitmap <span class="cov0" title="0">{
        byteSize := (maxNum + 7) &gt;&gt; 3
        return &amp;bitmap{
                bits:     make([]byte, byteSize),
                count:    0,
                byteSize: byteSize,
                capacity: maxNum,
        }
}</span>

// @desc 填入数字
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Set(num uint64) error <span class="cov0" title="0">{
        if num &gt; (this.capacity - 1) </span><span class="cov0" title="0">{
                return outRangeErr
        }</span>
        <span class="cov0" title="0">byteIndex, bitPos := this.offset(num)
        // 1 左移 bitPos 位 进行 按位或 (置为 1)
        this.Lock()
        defer this.Unlock()
        this.bits[byteIndex] |= bitmask[bitPos]
        this.count++
        return nil</span>
}

// @desc 清除填入的数字
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Reset(num uint64) error <span class="cov0" title="0">{
        if num &gt; (this.capacity - 1) </span><span class="cov0" title="0">{
                return outRangeErr
        }</span>
        <span class="cov0" title="0">byteIndex, bitPos := this.offset(num)
        // 重置为空位 (重置为 0)
        this.Lock()
        defer this.Unlock()
        this.bits[byteIndex] &amp;= ^bitmask[bitPos]
        this.count--
        return nil</span>
}

// @desc 数字是否在位图中
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Has(num uint64) bool <span class="cov0" title="0">{
        if num &gt; (this.capacity - 1) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">byteIndex := num &gt;&gt; 3
        bitPos := num % bitSize
        // 右移 bitPos 位 和 1 进行 按位与
        this.RLock()
        defer this.RUnlock()
        return !(this.bits[byteIndex]&amp;bitmask[bitPos] == 0)</span>
}

// @desc  获取某个数字的的字节位置和bit位置
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) offset(num uint64) (uint64, byte) <span class="cov0" title="0">{
        byteIndex := num &gt;&gt; 3         // 字节索引
        bitPos := byte(num % bitSize) // bit位置
        return byteIndex, bitPos
}</span>

// @desc 位图的容量
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Capacity() uint64 <span class="cov0" title="0">{
        return this.capacity
}</span>

// @desc 是否空位图
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) IsEmpty() bool <span class="cov0" title="0">{
        return this.count == 0
}</span>

// @desc 是否已填满
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) IsFully() bool <span class="cov0" title="0">{
        return this.count == this.capacity
}</span>

// @desc 已填入的数字个数
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Count() uint64 <span class="cov0" title="0">{
        return this.count
}</span>

// @desc 获取填入的数字切片
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) GetTotal() []uint64 <span class="cov0" title="0">{
        data := make([]uint64, 0)
        var lenth uint64 = 0
        if this.count == lenth </span><span class="cov0" title="0">{
                return data
        }</span>
        <span class="cov0" title="0">this.RLock()
        defer this.RUnlock()
        for byteIndex := uint64(0); byteIndex &lt; this.byteSize; byteIndex++ </span><span class="cov0" title="0">{
                if this.bits[byteIndex] == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for bitPos := range bitmask </span><span class="cov0" title="0">{
                        if !(this.bits[byteIndex]&amp;bitmask[bitPos] == 0) </span><span class="cov0" title="0">{
                                data = append(data, byteIndex&lt;&lt;3+uint64(bitPos))
                                lenth = uint64(len(data))
                                //元素已经找满
                                if this.count == lenth </span><span class="cov0" title="0">{
                                        return data
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return data</span>
}

// @desc 获取字节数组格式内容
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Bytes() []byte <span class="cov0" title="0">{
        return this.bits
}</span>

// @desc 获取base64格式内容
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) Base64() string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(this.bits)
}</span>

// @desc 获取二进制格式内容
// @auth liuguoqiang 2020-12-27
// @param
// @return
func (this *bitmap) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        byteIndex := this.byteSize
        this.RLock()
        defer this.RUnlock()
        for ; byteIndex &gt;= 0; byteIndex-- </span><span class="cov0" title="0">{
                sb.WriteString(byteToBinaryString(this.bits[byteIndex]))
                sb.WriteString(" ")
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

func byteToBinaryString(data byte) string <span class="cov0" title="0">{
        var sb strings.Builder
        for bitPos := 0; bitPos &lt; bitSize; bitPos++ </span><span class="cov0" title="0">{
                if (bitmask[7-bitPos] &amp; data) == 0 </span><span class="cov0" title="0">{
                        sb.WriteString("0")
                }</span> else<span class="cov0" title="0"> {
                        sb.WriteString("1")
                }</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cache

import (
        "container/list"
        "sync"
        "sync/atomic"
        "time"

        "github.com/tal-tech/go-zero/core/logx"
        "github.com/tal-tech/go-zero/core/mathx"
        "github.com/tal-tech/go-zero/core/syncx"
        "github.com/weblazy/easy/utils/timingwheel"
)

const (
        defaultCacheName = "proc"
        slots            = 300
        statInterval     = time.Minute
        // make the expiry unstable to avoid lots of cached items expire at the same time
        // make the unstable expiry to be [0.95, 1.05] * seconds
        expiryDeviation = 0.05
)

var emptyLruCache = emptyLru{}

type (
        // CacheOption defines the method to customize a Cache.
        CacheOption func(cache *Cache)

        // A Cache object is a in-memory cache.
        Cache struct {
                name           string
                lock           sync.Mutex
                data           map[string]interface{}
                expire         time.Duration
                timingWheel    *timingwheel.TimingWheel
                lruCache       lru
                barrier        syncx.SingleFlight
                unstableExpiry mathx.Unstable
                stats          *cacheStat
        }
)

// NewCache returns a Cache with given expire.
func NewCache(expire time.Duration, opts ...CacheOption) (*Cache, error) <span class="cov8" title="1">{
        cache := &amp;Cache{
                data:           make(map[string]interface{}),
                expire:         expire,
                lruCache:       emptyLruCache,
                barrier:        syncx.NewSingleFlight(),
                unstableExpiry: mathx.NewUnstable(expiryDeviation),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(cache)
        }</span>

        <span class="cov8" title="1">if len([]rune(cache.name)) == 0 </span><span class="cov8" title="1">{
                cache.name = defaultCacheName
        }</span>
        <span class="cov8" title="1">cache.stats = newCacheStat(cache.name, cache.size)

        timingWheel, err := timingwheel.NewTimingWheel(time.Second, slots, func(k, v interface{}) </span><span class="cov0" title="0">{
                key, ok := k.(string)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">cache.Del(key)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cache.timingWheel = timingWheel
        return cache, nil</span>
}

// Del deletes the item with the given key from c.
func (c *Cache) Del(key string) <span class="cov8" title="1">{
        c.lock.Lock()
        delete(c.data, key)
        c.lruCache.remove(key)
        c.lock.Unlock()
        c.timingWheel.RemoveTimer(key)
}</span>

// Get returns the item with the given key from c.
func (c *Cache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        value, ok := c.doGet(key)
        if ok </span><span class="cov8" title="1">{
                c.stats.IncrementHit()
        }</span> else<span class="cov8" title="1"> {
                c.stats.IncrementMiss()
        }</span>

        <span class="cov8" title="1">return value, ok</span>
}

// Set sets value into c with key.
func (c *Cache) Set(key string, value interface{}) <span class="cov8" title="1">{
        c.lock.Lock()
        _, ok := c.data[key]
        c.data[key] = value
        c.lruCache.add(key)
        c.lock.Unlock()

        expiry := c.unstableExpiry.AroundDuration(c.expire)
        if ok </span><span class="cov8" title="1">{
                c.timingWheel.MoveTimer(key, expiry)
        }</span> else<span class="cov8" title="1"> {
                c.timingWheel.SetTimer(key, value, expiry)
        }</span>
}

// Take returns the item with the given key.
// If the item is in c, return it directly.
// If not, use fetch method to get the item, set into c and return it.
func (c *Cache) Take(key string, fetch func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        if val, ok := c.doGet(key); ok </span><span class="cov8" title="1">{
                c.stats.IncrementHit()
                return val, nil
        }</span>

        <span class="cov8" title="1">var fresh bool
        val, err := c.barrier.Do(key, func() (interface{}, error) </span><span class="cov8" title="1">{
                // because O(1) on map search in memory, and fetch is an IO query
                // so we do double check, cache might be taken by another call
                if val, ok := c.doGet(key); ok </span><span class="cov0" title="0">{
                        return val, nil
                }</span>

                <span class="cov8" title="1">v, e := fetch()
                if e != nil </span><span class="cov8" title="1">{
                        return nil, e
                }</span>

                <span class="cov8" title="1">fresh = true
                c.Set(key, v)
                return v, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if fresh </span><span class="cov8" title="1">{
                c.stats.IncrementMiss()
                return val, nil
        }</span>

        // got the result from previous ongoing query
        <span class="cov8" title="1">c.stats.IncrementHit()
        return val, nil</span>
}

func (c *Cache) doGet(key string) (interface{}, bool) <span class="cov8" title="1">{
        c.lock.Lock()
        defer c.lock.Unlock()

        value, ok := c.data[key]
        if ok </span><span class="cov8" title="1">{
                c.lruCache.add(key)
        }</span>

        <span class="cov8" title="1">return value, ok</span>
}

func (c *Cache) onEvict(key string) <span class="cov8" title="1">{
        // already locked
        delete(c.data, key)
        c.timingWheel.RemoveTimer(key)
}</span>

func (c *Cache) size() int <span class="cov8" title="1">{
        c.lock.Lock()
        defer c.lock.Unlock()
        return len(c.data)
}</span>

// WithLimit customizes a Cache with items up to limit.
func WithLimit(limit int) CacheOption <span class="cov8" title="1">{
        return func(cache *Cache) </span><span class="cov8" title="1">{
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        cache.lruCache = newKeyLru(limit, cache.onEvict)
                }</span>
        }
}

// WithName customizes a Cache with the given name.
func WithName(name string) CacheOption <span class="cov8" title="1">{
        return func(cache *Cache) </span><span class="cov8" title="1">{
                cache.name = name
        }</span>
}

type (
        lru interface {
                add(key string)
                remove(key string)
        }

        emptyLru struct{}

        keyLru struct {
                limit    int
                evicts   *list.List
                elements map[string]*list.Element
                onEvict  func(key string)
        }
)

func (elru emptyLru) add(string) {<span class="cov8" title="1">
}</span>

func (elru emptyLru) remove(string) {<span class="cov8" title="1">
}</span>

func newKeyLru(limit int, onEvict func(key string)) *keyLru <span class="cov8" title="1">{
        return &amp;keyLru{
                limit:    limit,
                evicts:   list.New(),
                elements: make(map[string]*list.Element),
                onEvict:  onEvict,
        }
}</span>

func (klru *keyLru) add(key string) <span class="cov8" title="1">{
        if elem, ok := klru.elements[key]; ok </span><span class="cov8" title="1">{
                klru.evicts.MoveToFront(elem)
                return
        }</span>

        // Add new item
        <span class="cov8" title="1">elem := klru.evicts.PushFront(key)
        klru.elements[key] = elem

        // Verify size not exceeded
        if klru.evicts.Len() &gt; klru.limit </span><span class="cov8" title="1">{
                klru.removeOldest()
        }</span>
}

func (klru *keyLru) remove(key string) <span class="cov0" title="0">{
        if elem, ok := klru.elements[key]; ok </span><span class="cov0" title="0">{
                klru.removeElement(elem)
        }</span>
}

func (klru *keyLru) removeOldest() <span class="cov8" title="1">{
        elem := klru.evicts.Back()
        if elem != nil </span><span class="cov8" title="1">{
                klru.removeElement(elem)
        }</span>
}

func (klru *keyLru) removeElement(e *list.Element) <span class="cov8" title="1">{
        klru.evicts.Remove(e)
        key := e.Value.(string)
        delete(klru.elements, key)
        klru.onEvict(key)
}</span>

type cacheStat struct {
        name         string
        hit          uint64
        miss         uint64
        sizeCallback func() int
}

func newCacheStat(name string, sizeCallback func() int) *cacheStat <span class="cov8" title="1">{
        st := &amp;cacheStat{
                name:         name,
                sizeCallback: sizeCallback,
        }
        go st.statLoop()
        return st
}</span>

func (cs *cacheStat) IncrementHit() <span class="cov8" title="1">{
        atomic.AddUint64(&amp;cs.hit, 1)
}</span>

func (cs *cacheStat) IncrementMiss() <span class="cov8" title="1">{
        atomic.AddUint64(&amp;cs.miss, 1)
}</span>

func (cs *cacheStat) statLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(statInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                hit := atomic.SwapUint64(&amp;cs.hit, 0)
                miss := atomic.SwapUint64(&amp;cs.miss, 0)
                total := hit + miss
                if total == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">percent := 100 * float32(hit) / float32(total)
                logx.Statf("cache(%s) - qpm: %d, hit_ratio: %.1f%%, elements: %d, hit: %d, miss: %d",
                        cs.name, total, percent, cs.sizeCallback(), hit, miss)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package csvx

import (
        "bufio"
        "encoding/csv"
        "os"
        "strings"
)

type CSV struct {
        path         string
        wfile        *os.File
        rfile        *os.File
        w            *csv.Writer
        r            *bufio.Reader
        rowSeparator string
}

// NewCSV return a CSV
func NewCSV(path string, rowSeparator rune, lineSeparator string) (*CSV, error) <span class="cov0" title="0">{
        wfile, err := os.OpenFile(path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rfile, err := os.OpenFile(path, os.O_RDONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">w := csv.NewWriter(wfile)
        w.Comma = rowSeparator
        if lineSeparator == `\r\n` </span><span class="cov0" title="0">{
                w.UseCRLF = true
        }</span>
        <span class="cov0" title="0">r := bufio.NewReader(rfile)
        return &amp;CSV{
                path:         path,
                wfile:        wfile,
                rfile:        rfile,
                w:            w,
                r:            r,
                rowSeparator: string(rowSeparator),
        }, nil</span>
}

// Write truncate and write one line
func (this *CSV) Write(str []string) error <span class="cov0" title="0">{
        err := this.wfile.Truncate(0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = this.w.Write(str)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">this.w.Flush()
        return nil</span>
}

// Append append one line
func (this *CSV) Append(str []string) error <span class="cov0" title="0">{
        err := this.w.Write(str)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">this.w.Flush()
        return nil</span>
}

// Truncate
func (this *CSV) Truncate() error <span class="cov0" title="0">{
        return this.wfile.Truncate(0)
}</span>

// Reset
func (this *CSV) Reset() (int64, error) <span class="cov0" title="0">{
        return this.rfile.Seek(0, 0)
}</span>

// ReadLine read one line
func (this *CSV) ReadLine() ([]string, error) <span class="cov0" title="0">{
        line, _, err := this.r.ReadLine() //以'\n'为结束符读入一行
        return strings.Split(string(line), this.rowSeparator), err
}</span>

// Close close file
func (this *CSV) Close() error <span class="cov0" title="0">{
        err := this.wfile.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return this.rfile.Close()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package errorx

import "sync"

type AtomicError struct {
        err  error
        lock sync.Mutex
}

func (ae *AtomicError) Set(err error) <span class="cov8" title="1">{
        ae.lock.Lock()
        ae.err = err
        ae.lock.Unlock()
}</span>

func (ae *AtomicError) Load() error <span class="cov8" title="1">{
        ae.lock.Lock()
        err := ae.err
        ae.lock.Unlock()
        return err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package errorx

import "bytes"

type BatchError []error

func (be BatchError) Error() string <span class="cov8" title="1">{
        var buf bytes.Buffer

        for i := range be </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte('\n')
                }</span>
                <span class="cov8" title="1">buf.WriteString(be[i].Error())</span>
        }

        <span class="cov8" title="1">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package filex

import (
        "io/ioutil"
        "os"
)

func Read(path string) ([]byte, error) <span class="cov8" title="1">{
        fi, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer fi.Close()
        fd, err := ioutil.ReadAll(fi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fd, nil</span>
}

func Write(path string, b []byte, isAppend bool) error <span class="cov8" title="1">{
        flag := os.O_WRONLY | os.O_TRUNC | os.O_CREATE
        if isAppend </span><span class="cov0" title="0">{
                flag = os.O_WRONLY | os.O_APPEND | os.O_CREATE
        }</span>
        <span class="cov8" title="1">fd, err := os.OpenFile(path, flag, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fd.Close()
        fd.Write(b)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package gpool

import (
        "fmt"
        "sync"
)

type GPool struct {
        lock      sync.Mutex
        maxCount  int64
        curCount  int64
        waitGroup sync.WaitGroup
        jobs      chan interface{}
        fun       func(param interface{})
        closeCh   chan bool
}

var NilErr = fmt.Errorf("param can not be nil")
var CloseErr = fmt.Errorf("pool was closed")

func NewGPool(maxCount int64, fun func(param interface{})) *GPool <span class="cov0" title="0">{
        return &amp;GPool{
                maxCount: maxCount,
                fun:      fun,
                jobs:     make(chan interface{}, 10),
                closeCh:  make(chan bool),
        }
}</span>

func (g *GPool) Run(param interface{}) error <span class="cov0" title="0">{
        if param == nil </span><span class="cov0" title="0">{
                return NilErr
        }</span>
        <span class="cov0" title="0">g.lock.Lock()
        defer g.lock.Unlock()
        select </span>{
        case &lt;-g.closeCh:<span class="cov0" title="0">
                return CloseErr</span>
        default:<span class="cov0" title="0">
                if g.curCount &lt; g.maxCount </span><span class="cov0" title="0">{
                        g.waitGroup.Add(1)
                        g.curCount++
                        go g.worker()
                }</span>
                <span class="cov0" title="0">g.jobs &lt;- param
                return nil</span>
        }

}

func (g *GPool) Clear() <span class="cov0" title="0">{
        g.lock.Lock()
        defer g.lock.Unlock()
        select </span>{
        case &lt;-g.closeCh:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                for g.curCount &gt; 0 </span><span class="cov0" title="0">{
                        g.curCount--
                        g.jobs &lt;- nil
                }</span>
        }
}

func (g *GPool) Close() <span class="cov0" title="0">{
        g.lock.Lock()
        select </span>{
        case &lt;-g.closeCh:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(g.closeCh)
                close(g.jobs)</span>
        }
        <span class="cov0" title="0">g.lock.Unlock()
        g.waitGroup.Wait()</span>
}

func (g *GPool) worker() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        go g.worker()
                        fmt.Printf("%#v\n", p)
                }</span> else<span class="cov0" title="0"> {
                        g.waitGroup.Done()
                }</span>
        }()
        <span class="cov0" title="0">for j := range g.jobs </span><span class="cov0" title="0">{
                if j == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">g.fun(j)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package httpx

import (
        "errors"
        "time"

        "github.com/go-resty/resty/v2"
        "github.com/sunmi-OS/gocore/v2/utils"
)

type HttpClient struct {
        Client  *resty.Client
        Request *resty.Request
}

func New() *HttpClient <span class="cov0" title="0">{

        // Create a Resty Client
        client := resty.New()

        // Retries are configured per client
        client.
                // Set retry count to non zero to enable retries
                SetRetryCount(10).
                // TimeOut
                SetTimeout(5 * time.Second).
                // You can override initial retry wait time.
                // Default is 100 milliseconds.
                SetRetryWaitTime(2 * time.Second).
                // MaxWaitTime can be overridden as well.
                // Default is 2 seconds.
                SetRetryMaxWaitTime(20 * time.Second).
                // SetRetryAfter sets callback to calculate wait time between retries.
                // Default (nil) implies exponential backoff with jitter
                SetRetryAfter(func(client *resty.Client, resp *resty.Response) (time.Duration, error) </span><span class="cov0" title="0">{
                        return 0, errors.New("quota exceeded")
                }</span>)

        <span class="cov0" title="0">return &amp;HttpClient{
                Client:  client,
                Request: client.R(),
        }</span>
}

func (h *HttpClient) SetTrace(header interface{}) *HttpClient <span class="cov0" title="0">{
        trace := utils.SetHeader(header)
        h.Request.Header = trace.HttpHeader
        return h
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package httpx

import (
        "fmt"
        "net/url"

        "github.com/weblazy/easy/utils/stringx"
)

// @desc 编译http参数
// @auth liuguoqiang 2020-03-20
// @param
// @return
func MapToQuery(params map[string]interface{}, urlEncode ...bool) (string, error) <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("param is nil")
        }</span>
        <span class="cov0" title="0">v := make(url.Values)
        for key := range params </span><span class="cov0" title="0">{
                value, err := stringx.ToString(params[key])
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">v.Add(key, value)</span>
        }
        <span class="cov0" title="0">encodeStr := v.Encode()
        if len(urlEncode) &gt; 0 &amp;&amp; urlEncode[0] </span><span class="cov0" title="0">{
                return encodeStr, nil
        }</span>
        <span class="cov0" title="0">decodeStr, _ := url.QueryUnescape(encodeStr)
        return decodeStr, nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (C) 2018  Qi Yin &lt;qiyin@thinkeridea.com&gt;
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

package httpx

import (
        "errors"
        "math"
        "net"
        "net/http"
        "strings"
)

// HasLocalIPddr 检测 IP 地址字符串是否是内网地址
func HasLocalIPddr(ip string) bool <span class="cov0" title="0">{
        return HasLocalIP(net.ParseIP(ip))
}</span>

// HasLocalIP 检测 IP 地址是否是内网地址
// 通过直接对比ip段范围效率更高，详见：https://github.com/thinkeridea/go-extend/issues/2
func HasLocalIP(ip net.IP) bool <span class="cov0" title="0">{
        if ip.IsLoopback() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">ip4 := ip.To4()
        if ip4 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return ip4[0] == 10 || // 10.0.0.0/8
                (ip4[0] == 172 &amp;&amp; ip4[1] &gt;= 16 &amp;&amp; ip4[1] &lt;= 31) || // 172.16.0.0/12
                (ip4[0] == 169 &amp;&amp; ip4[1] == 254) || // 169.254.0.0/16
                (ip4[0] == 192 &amp;&amp; ip4[1] == 168)</span> // 192.168.0.0/16
}

// ClientIP 尽最大努力实现获取客户端 IP 的算法。
// 解析 X-Real-IP 和 X-Forwarded-For 以便于反向代理（nginx 或 haproxy）可以正常工作。
func ClientIP(r *http.Request) string <span class="cov0" title="0">{
        xForwardedFor := r.Header.Get("X-Forwarded-For")
        ip := strings.TrimSpace(strings.Split(xForwardedFor, ",")[0])
        if ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">ip = strings.TrimSpace(r.Header.Get("X-Real-Ip"))
        if ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">if ip, _, err := net.SplitHostPort(strings.TrimSpace(r.RemoteAddr)); err == nil </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// ClientPublicIP 尽最大努力实现获取客户端公网 IP 的算法。
// 解析 X-Real-IP 和 X-Forwarded-For 以便于反向代理（nginx 或 haproxy）可以正常工作。
func ClientPublicIP(r *http.Request) string <span class="cov0" title="0">{
        var ip string
        ip = strings.TrimSpace(r.Header.Get("X-Original-Forwarded-For"))
        if ip != "" &amp;&amp; !HasLocalIPddr(ip) </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov0" title="0">for _, ip = range strings.Split(r.Header.Get("X-Forwarded-For"), ",") </span><span class="cov0" title="0">{
                ip = strings.TrimSpace(ip)
                if ip != "" &amp;&amp; !HasLocalIPddr(ip) </span><span class="cov0" title="0">{
                        return ip
                }</span>
        }

        <span class="cov0" title="0">ip = strings.TrimSpace(r.Header.Get("X-Real-Ip"))
        if ip != "" &amp;&amp; !HasLocalIPddr(ip) </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">if ip, _, err := net.SplitHostPort(strings.TrimSpace(r.RemoteAddr)); err == nil </span><span class="cov0" title="0">{
                if !HasLocalIPddr(ip) </span><span class="cov0" title="0">{
                        return ip
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// RemoteIP 通过 RemoteAddr 获取 IP 地址， 只是一个快速解析方法。
func RemoteIP(r *http.Request) string <span class="cov0" title="0">{
        if ip, _, err := net.SplitHostPort(strings.TrimSpace(r.RemoteAddr)); err == nil </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// IPString2Long 把ip字符串转为数值
func IPString2Long(ip string) (uint, error) <span class="cov0" title="0">{
        b := net.ParseIP(ip).To4()
        if b == nil </span><span class="cov0" title="0">{
                return 0, errors.New("invalid ipv4 format")
        }</span>

        <span class="cov0" title="0">return uint(b[3]) | uint(b[2])&lt;&lt;8 | uint(b[1])&lt;&lt;16 | uint(b[0])&lt;&lt;24, nil</span>
}

// Long2IPString 把数值转为ip字符串
func Long2IPString(i uint) (string, error) <span class="cov0" title="0">{
        if i &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                return "", errors.New("beyond the scope of ipv4")
        }</span>

        <span class="cov0" title="0">ip := make(net.IP, net.IPv4len)
        ip[0] = byte(i &gt;&gt; 24)
        ip[1] = byte(i &gt;&gt; 16)
        ip[2] = byte(i &gt;&gt; 8)
        ip[3] = byte(i)

        return ip.String(), nil</span>
}

// IP2Long 把net.IP转为数值
func IP2Long(ip net.IP) (uint, error) <span class="cov0" title="0">{
        b := ip.To4()
        if b == nil </span><span class="cov0" title="0">{
                return 0, errors.New("invalid ipv4 format")
        }</span>

        <span class="cov0" title="0">return uint(b[3]) | uint(b[2])&lt;&lt;8 | uint(b[1])&lt;&lt;16 | uint(b[0])&lt;&lt;24, nil</span>
}

// Long2IP 把数值转为net.IP
func Long2IP(i uint) (net.IP, error) <span class="cov0" title="0">{
        if i &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                return nil, errors.New("beyond the scope of ipv4")
        }</span>

        <span class="cov0" title="0">ip := make(net.IP, net.IPv4len)
        ip[0] = byte(i &gt;&gt; 24)
        ip[1] = byte(i &gt;&gt; 16)
        ip[2] = byte(i &gt;&gt; 8)
        ip[3] = byte(i)

        return ip, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package httpx

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/go-resty/resty/v2"
        "github.com/spf13/cast"
        "github.com/sunmi-OS/gocore/v2/glog"
        "github.com/sunmi-OS/gocore/v2/glog/sls"
)

type Log interface {
        Info(obj *LogObject) error
}

type LogObject struct {
        Url             string        `json:"url"`
        Method          string        `json:"method"`
        RequestHders    http.Header   `json:"request_headers"`
        RequestRawBody  interface{}   `json:"request_raw_body"`
        ResponseHeaders http.Header   `json:"response_headers"`
        ResponseBody    string        `json:"response_body"`
        StartTime       string        `json:"start_time"`
        Duration        time.Duration `json:"duration"`
        Status          int           `json:"status"`
}

func (h *HttpClient) SetLog(log Log) *HttpClient <span class="cov0" title="0">{
        err := h.Client.OnAfterResponse(func(client *resty.Client, resp *resty.Response) error </span><span class="cov0" title="0">{
                r := resp.Request
                obj := &amp;LogObject{
                        Url:             r.URL,
                        Method:          r.Method,
                        RequestHders:    r.Header,
                        RequestRawBody:  r.Body,
                        ResponseHeaders: resp.Header(),
                        ResponseBody:    string(resp.Body()),
                        StartTime:       r.Time.Format("2006-01-02 15:04:05"),
                        Duration:        resp.Time() / time.Millisecond,
                        Status:          resp.StatusCode(),
                }
                log.Info(obj)
                return nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%#v\n", err)
        }</span>
        <span class="cov0" title="0">return h</span>
}

type GocoreLog struct {
}

func NewGocoreLog() *GocoreLog <span class="cov0" title="0">{
        return &amp;GocoreLog{}
}</span>

func (l *GocoreLog) Info(obj *LogObject) error <span class="cov0" title="0">{
        data, _ := json.Marshal(obj)
        glog.InfoF(string(data))
        return nil
}</span>

func NewAliyunLog(topic string) *AliyunLog <span class="cov0" title="0">{
        return &amp;AliyunLog{topic: topic}
}</span>

type AliyunLog struct {
        topic string
}

//  使用阿里云日志需要提前调用sls.InitLog初始化
func (l *AliyunLog) Info(obj *LogObject) error <span class="cov0" title="0">{
        requestHeaderBytes, _ := json.Marshal(obj.RequestHders)
        requestBodyBytes, _ := json.Marshal(obj.RequestRawBody)
        responseHeaderBytes, _ := json.Marshal(obj.ResponseHeaders)
        _ = sls.Info(l.topic, map[string]string{
                "url":              obj.Url,
                "method":           obj.Method,
                "request_headers":  string(requestHeaderBytes),
                "request_raw_body": string(requestBodyBytes),
                "response_headers": string(responseHeaderBytes),
                "start_time":       obj.StartTime,
                "duration":         cast.ToString(obj.Duration),
                "status":           cast.ToString(obj.Status),
        })
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package lang

import "log"

var Placeholder PlaceholderType

type (
        GenericType     = interface{}
        PlaceholderType = struct{}
)

func Must(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package list implements a doubly linked list.
//
// To iterate over a list (where l is a *List):
//        for e := l.Front(); e != nil; e = e.Next() {
//                // do something with e.Value
//        }
//
package list

// Element is an element of a linked list.
type Element struct {
        // Next and previous pointers in the doubly-linked list of elements.
        // To simplify the implementation, internally a list l is implemented
        // as a ring, such that &amp;l.root is both the next element of the last
        // list element (l.Back()) and the previous element of the first list
        // element (l.Front()).
        next, prev *Element

        // The list to which this element belongs.
        // list *List

        // The value stored with this element.
        Value interface{}
}

// Next returns the next list element or nil.
func (l *List) Next(e *Element) *Element <span class="cov0" title="0">{
        if p := e.next; l != nil &amp;&amp; p != &amp;l.root </span><span class="cov0" title="0">{
                return p
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// List represents a doubly linked list.
// The zero value for List is an empty list ready to use.
type List struct {
        root Element // sentinel list element, only &amp;root, root.prev, and root.next are used
        len  int     // current list length excluding (this) sentinel element
}

// Init initializes or clears list l.
func (l *List) Init() *List <span class="cov8" title="1">{
        l.root.next = &amp;l.root
        l.root.prev = &amp;l.root
        l.len = 0
        return l
}</span>

// New returns an initialized list.
func New() *List <span class="cov8" title="1">{ return new(List).Init() }</span>

// Len returns the number of elements of list l.
// The complexity is O(1).
func (l *List) Len() int <span class="cov0" title="0">{ return l.len }</span>

// Front returns the first element of list l or nil if the list is empty.
func (l *List) Front() *Element <span class="cov0" title="0">{
        if l.len == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return l.root.next</span>
}

// Back returns the last element of list l or nil if the list is empty.
func (l *List) Back() *Element <span class="cov8" title="1">{
        if l.len == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return l.root.prev</span>
}

// lazyInit lazily initializes a zero List value.
func (l *List) lazyInit() <span class="cov8" title="1">{
        if l.root.next == nil </span><span class="cov0" title="0">{
                l.Init()
        }</span>
}

// insert inserts e after at, increments l.len, and returns e.
func (l *List) insert(e, at *Element) *Element <span class="cov8" title="1">{
        e.prev = at
        e.next = at.next
        e.prev.next = e
        e.next.prev = e
        // e.list = l
        l.len++
        return e
}</span>

// insertValue is a convenience wrapper for insert(&amp;Element{Value: v}, at).
func (l *List) insertValue(v interface{}, at *Element) *Element <span class="cov8" title="1">{
        return l.insert(&amp;Element{Value: v}, at)
}</span>

// remove removes e from its list, decrements l.len, and returns e.
func (l *List) remove(e *Element) *Element <span class="cov8" title="1">{
        e.prev.next = e.next
        e.next.prev = e.prev
        e.next = nil // avoid memory leaks
        e.prev = nil // avoid memory leaks
        // e.list = nil
        l.len--
        return e
}</span>

// move moves e to next to at and returns e.
func (l *List) move(e, at *Element) *Element <span class="cov0" title="0">{
        if e == at </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov0" title="0">e.prev.next = e.next
        e.next.prev = e.prev

        e.prev = at
        e.next = at.next
        e.prev.next = e
        e.next.prev = e

        return e</span>
}

// Remove removes e from l if e is an element of list l.
// It returns the element value e.Value.
// The element must not be nil.
func (l *List) Remove(e *Element) interface{} <span class="cov8" title="1">{
        if l != nil </span><span class="cov8" title="1">{
                // TODO
                // if e.list == l, l must have been initialized when e was inserted
                // in l or l == nil (e is a zero Element) and l.remove will crash
                l.remove(e)
        }</span>
        <span class="cov8" title="1">return e.Value</span>
}

// PushFront inserts a new element e with value v at the front of list l and returns e.
func (l *List) PushFront(v interface{}) *Element <span class="cov0" title="0">{
        l.lazyInit()
        return l.insertValue(v, &amp;l.root)
}</span>

// PushBack inserts a new element e with value v at the back of list l and returns e.
func (l *List) PushBack(v interface{}) *Element <span class="cov8" title="1">{
        l.lazyInit()
        return l.insertValue(v, l.root.prev)
}</span>

// Merge
func (l *List) MergeBack(l1 *List) <span class="cov0" title="0">{
        if l1.Len() == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">l.lazyInit()
        l1.root.next.prev = l.root.prev
        l1.root.prev.next = &amp;l.root
        l.root.prev.next = l1.root.next
        l.root.prev = l1.root.prev
        l.len += l1.len</span>
}

// // InsertBefore inserts a new element e with value v immediately before mark and returns e.
// // If mark is not an element of l, the list is not modified.
// // The mark must not be nil.
// func (l *List) InsertBefore(v interface{}, mark *Element) *Element {
//         if mark.list != l {
//                 return nil
//         }
//         // see comment in List.Remove about initialization of l
//         return l.insertValue(v, mark.prev)
// }

// // InsertAfter inserts a new element e with value v immediately after mark and returns e.
// // If mark is not an element of l, the list is not modified.
// // The mark must not be nil.
// func (l *List) InsertAfter(v interface{}, mark *Element) *Element {
//         if mark.list != l {
//                 return nil
//         }
//         // see comment in List.Remove about initialization of l
//         return l.insertValue(v, mark)
// }

// // MoveToFront moves element e to the front of list l.
// // If e is not an element of l, the list is not modified.
// // The element must not be nil.
// func (l *List) MoveToFront(e *Element) {
//         if e.list != l || l.root.next == e {
//                 return
//         }
//         // see comment in List.Remove about initialization of l
//         l.move(e, &amp;l.root)
// }

// // MoveToBack moves element e to the back of list l.
// // If e is not an element of l, the list is not modified.
// // The element must not be nil.
// func (l *List) MoveToBack(e *Element) {
//         if e.list != l || l.root.prev == e {
//                 return
//         }
//         // see comment in List.Remove about initialization of l
//         l.move(e, l.root.prev)
// }

// // MoveBefore moves element e to its new position before mark.
// // If e or mark is not an element of l, or e == mark, the list is not modified.
// // The element and mark must not be nil.
// func (l *List) MoveBefore(e, mark *Element) {
//         if e.list != l || e == mark || mark.list != l {
//                 return
//         }
//         l.move(e, mark.prev)
// }

// // MoveAfter moves element e to its new position after mark.
// // If e or mark is not an element of l, or e == mark, the list is not modified.
// // The element and mark must not be nil.
// func (l *List) MoveAfter(e, mark *Element) {
//         if e.list != l || e == mark || mark.list != l {
//                 return
//         }
//         l.move(e, mark)
// }

// // PushBackList inserts a copy of another list at the back of list l.
// // The lists l and other may be the same. They must not be nil.
// func (l *List) PushBackList(other *List) {
//         l.lazyInit()
//         for i, e := other.Len(), other.Front(); i &gt; 0; i, e = i-1, e.Next() {
//                 l.insertValue(e.Value, l.root.prev)
//         }
// }

// // PushFrontList inserts a copy of another list at the front of list l.
// // The lists l and other may be the same. They must not be nil.
// func (l *List) PushFrontList(other *List) {
//         l.lazyInit()
//         for i, e := other.Len(), other.Back(); i &gt; 0; i, e = i-1, e.Prev() {
//                 l.insertValue(e.Value, &amp;l.root)
//         }
// }
</pre>
		
		<pre class="file" id="file15" style="display: none">package logx

import (
        "encoding/json"
        "fmt"
        "runtime"
        "time"
)

type (
        Param struct {
                Time string      `json:"time"`
                File string      `json:"file"`
                Data interface{} `json:"data"`
        }
)

func Info(args ...interface{}) <span class="cov0" title="0">{
        _, file, line, ok := runtime.Caller(1)
        if ok </span><span class="cov0" title="0">{
                data, _ := json.Marshal(&amp;Param{
                        Time: time.Now().Format("2006-01-02 15:04:05"),
                        File: fmt.Sprintf("%s:%d", file, line),
                        Data: args,
                })
                fmt.Printf("%s\n", string(data))
        }</span>
}

func Infof(format string, a ...interface{}) <span class="cov0" title="0">{
        _, file, line, ok := runtime.Caller(1)
        if ok </span><span class="cov0" title="0">{
                data, _ := json.Marshal(&amp;Param{
                        Time: time.Now().Format("2006-01-02 15:04:05"),
                        File: fmt.Sprintf("%s:%d", file, line),
                        Data: fmt.Sprintf(format, a...),
                })
                fmt.Printf("%s\n", string(data))
        }</span>
}

func Stack(args ...interface{}) <span class="cov8" title="1">{
        param := &amp;Param{
                Time: time.Now().Format("2006-01-02 15:04:05"),
                File: "",
                Data: args,
        }

        for i := 1; ; i++ </span><span class="cov8" title="1">{
                pc, file, line, ok := runtime.Caller(i)
                if !ok </span><span class="cov8" title="1">{
                        data, _ := json.Marshal(param)
                        fmt.Printf("%s\n", string(data))
                        break</span>
                }
                <span class="cov8" title="1">f := runtime.FuncForPC(pc)
                if f.Name() != "runtime.main" &amp;&amp; f.Name() != "runtime.goexit" </span><span class="cov8" title="1">{
                        param.File += fmt.Sprintf("%s:%d|------|", file, line)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mapreduce

import (
        "errors"
        "fmt"
        "sync"

        "github.com/weblazy/easy/utils/errorx"

        "github.com/weblazy/easy/utils/syncx"

        "github.com/weblazy/easy/utils/threading"

        "github.com/weblazy/easy/utils/lang"
)

const (
        defaultWorkers = 16
        minWorkers     = 1
)

var ErrCancelWithNil = errors.New("mapreduce cancelled with nil")

type (
        GenerateFunc    func(source chan&lt;- interface{})
        MapFunc         func(item interface{}, writer Writer)
        VoidMapFunc     func(item interface{})
        MapperFunc      func(item interface{}, writer Writer, cancel func(error))
        ReducerFunc     func(pipe &lt;-chan interface{}, writer Writer, cancel func(error))
        VoidReducerFunc func(pipe &lt;-chan interface{}, cancel func(error))
        Option          func(opts *mapReduceOptions)

        mapReduceOptions struct {
                workers int
        }

        Writer interface {
                Write(v interface{})
        }
)

func Finish(fns ...func() error) error <span class="cov8" title="1">{
        if len(fns) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return MapReduceVoid(func(source chan&lt;- interface{}) </span><span class="cov8" title="1">{
                for _, fn := range fns </span><span class="cov8" title="1">{
                        source &lt;- fn
                }</span>
        }, func(item interface{}, writer Writer, cancel func(error)) <span class="cov8" title="1">{
                fn := item.(func() error)
                if err := fn(); err != nil </span><span class="cov8" title="1">{
                        cancel(err)
                }</span>
        }, func(pipe &lt;-chan interface{}, cancel func(error)) <span class="cov8" title="1">{
                drain(pipe)
        }</span>, WithWorkers(len(fns)))
}

func FinishVoid(fns ...func()) <span class="cov8" title="1">{
        if len(fns) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">MapVoid(func(source chan&lt;- interface{}) </span><span class="cov8" title="1">{
                for _, fn := range fns </span><span class="cov8" title="1">{
                        source &lt;- fn
                }</span>
        }, func(item interface{}) <span class="cov8" title="1">{
                fn := item.(func())
                fn()
        }</span>, WithWorkers(len(fns)))
}

func Map(generate GenerateFunc, mapper MapFunc, opts ...Option) chan interface{} <span class="cov8" title="1">{
        options := buildOptions(opts...)
        source := buildSource(generate)
        collector := make(chan interface{}, options.workers)
        done := syncx.NewDoneChan()

        go mapDispatcher(mapper, source, collector, done.Done(), options.workers)

        return collector
}</span>

func MapReduce(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc, opts ...Option) (interface{}, error) <span class="cov8" title="1">{
        source := buildSource(generate)
        return MapReduceWithSource(source, mapper, reducer, opts...)
}</span>

func MapReduceWithSource(source &lt;-chan interface{}, mapper MapperFunc, reducer ReducerFunc,
        opts ...Option) (interface{}, error) <span class="cov8" title="1">{
        options := buildOptions(opts...)
        output := make(chan interface{})
        collector := make(chan interface{}, options.workers)
        done := syncx.NewDoneChan()
        writer := newGuardedWriter(output, done.Done())
        var retErr errorx.AtomicError
        cancel := once(func(err error) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        retErr.Set(err)
                }</span> else<span class="cov8" title="1"> {
                        retErr.Set(ErrCancelWithNil)
                }</span>

                <span class="cov8" title="1">done.Close()
                close(output)</span>
        })

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                cancel(fmt.Errorf("%v", r))
                        }</span>
                }()
                <span class="cov8" title="1">reducer(collector, writer, cancel)</span>
        }()
        <span class="cov8" title="1">go mapperDispatcher(mapper, source, collector, done.Done(), cancel, options.workers)

        value, ok := &lt;-output
        if err := retErr.Load(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if ok </span><span class="cov8" title="1">{
                return value, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, nil
        }</span>
}

func MapReduceVoid(generator GenerateFunc, mapper MapperFunc, reducer VoidReducerFunc, opts ...Option) error <span class="cov8" title="1">{
        _, err := MapReduce(generator, mapper, func(input &lt;-chan interface{}, writer Writer, cancel func(error)) </span><span class="cov8" title="1">{
                reducer(input, cancel)
                // We need to write a placeholder to let MapReduce to continue on reducer done,
                // otherwise, all goroutines are waiting. The placeholder will be discarded by MapReduce.
                writer.Write(lang.Placeholder)
        }</span>, opts...)
        <span class="cov8" title="1">return err</span>
}

func MapVoid(generate GenerateFunc, mapper VoidMapFunc, opts ...Option) <span class="cov8" title="1">{
        drain(Map(generate, func(item interface{}, writer Writer) </span><span class="cov8" title="1">{
                mapper(item)
        }</span>, opts...))
}

func WithWorkers(workers int) Option <span class="cov8" title="1">{
        return func(opts *mapReduceOptions) </span><span class="cov8" title="1">{
                if workers &lt; minWorkers </span><span class="cov8" title="1">{
                        opts.workers = minWorkers
                }</span> else<span class="cov8" title="1"> {
                        opts.workers = workers
                }</span>
        }
}

func buildOptions(opts ...Option) *mapReduceOptions <span class="cov8" title="1">{
        options := newOptions()
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(options)
        }</span>

        <span class="cov8" title="1">return options</span>
}

func buildSource(generate GenerateFunc) chan interface{} <span class="cov8" title="1">{
        source := make(chan interface{})
        threading.GoSafe(func() </span><span class="cov8" title="1">{
                defer close(source)
                generate(source)
        }</span>)

        <span class="cov8" title="1">return source</span>
}

// drain drains the channel, which is useful when no output to the channel returned by Map.
func drain(channel &lt;-chan interface{}) <span class="cov8" title="1">{
        // drain the channel
        for range channel </span>{<span class="cov0" title="0">
        }</span>
}

func executeMappers(mapper MapFunc, input &lt;-chan interface{}, collector chan&lt;- interface{},
        done &lt;-chan lang.PlaceholderType, workers int) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        defer func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(collector)
        }</span>()

        <span class="cov8" title="1">pool := make(chan lang.PlaceholderType, workers)
        writer := newGuardedWriter(collector, done)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-done:<span class="cov8" title="1">
                        return</span>
                case pool &lt;- lang.Placeholder:<span class="cov8" title="1">
                        item, ok := &lt;-input
                        if !ok </span><span class="cov8" title="1">{
                                &lt;-pool
                                return
                        }</span>

                        <span class="cov8" title="1">wg.Add(1)
                        // better to safely run caller defined method
                        threading.GoSafe(func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        wg.Done()
                                        &lt;-pool
                                }</span>()

                                <span class="cov8" title="1">mapper(item, writer)</span>
                        })
                }
        }
}

func mapDispatcher(mapper MapFunc, input &lt;-chan interface{}, collector chan&lt;- interface{},
        done &lt;-chan lang.PlaceholderType, workers int) <span class="cov8" title="1">{
        executeMappers(func(item interface{}, writer Writer) </span><span class="cov8" title="1">{
                mapper(item, writer)
        }</span>, input, collector, done, workers)
}

func mapperDispatcher(mapper MapperFunc, input &lt;-chan interface{}, collector chan&lt;- interface{},
        done &lt;-chan lang.PlaceholderType, cancel func(error), workers int) <span class="cov8" title="1">{
        executeMappers(func(item interface{}, writer Writer) </span><span class="cov8" title="1">{
                mapper(item, writer, cancel)
        }</span>, input, collector, done, workers)
}

func newOptions() *mapReduceOptions <span class="cov8" title="1">{
        return &amp;mapReduceOptions{
                workers: defaultWorkers,
        }
}</span>

func once(fn func(error)) func(error) <span class="cov8" title="1">{
        once := new(sync.Once)
        return func(err error) </span><span class="cov8" title="1">{
                once.Do(func() </span><span class="cov8" title="1">{
                        fn(err)
                }</span>)
        }
}

type guardedWriter struct {
        channel chan&lt;- interface{}
        done    &lt;-chan lang.PlaceholderType
}

func newGuardedWriter(channel chan&lt;- interface{}, done &lt;-chan lang.PlaceholderType) guardedWriter <span class="cov8" title="1">{
        return guardedWriter{
                channel: channel,
                done:    done,
        }
}</span>

func (gw guardedWriter) Write(v interface{}) <span class="cov8" title="1">{
        select </span>{
        case &lt;-gw.done:<span class="cov8" title="1">
                return</span>
        default:<span class="cov8" title="1">
                gw.channel &lt;- v</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mapx

import (
        "encoding/xml"
        "io"
)

type Map map[string]string

type xmlMapEntry struct {
        XMLName xml.Name
        Value   string `xml:",chardata"`
}

func (m Map) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        //构建xml 输出头部
        var err error
        for key, value := range m </span><span class="cov0" title="0">{
                name := xml.Name{Space: "", Local: key}
                err = e.EncodeToken(xml.StartElement{Name: name})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = e.EncodeToken(xml.CharData(value))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = e.EncodeToken(xml.EndElement{Name: name})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *Map) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        *m = Map{}
        for </span><span class="cov0" title="0">{
                var e xmlMapEntry

                err := d.Decode(&amp;e)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">(*m)[e.XMLName.Local] = e.Value</span>
        }
        <span class="cov0" title="0">return nil</span>
}

/**
 * @desc 校验
 */
func IsExist(data map[string]interface{}, name string) bool <span class="cov0" title="0">{
        _, ok := data[name]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package monitor

import (
        "fmt"

        http_request "github.com/sunmi-OS/gocore/http-request"
)

type (
        DingTalk struct {
                Handler
                Url       string `json:"url"`
                atMobiles []string
                isAtAll   bool
        }

        TextMsg struct {
                Msgtype string `json:"msgtype"`
                Text    struct {
                        Content string `json:"content"`
                } `json:"text"`
                At struct {
                        AtMobiles []string `json:"atMobiles"`
                        IsAtAll   bool     `json:"isAtAll"`
                } `json:"at"`
        }
)

// @desc
// @auth liuguoqiang 2020-12-07
// @param
// @return
func NewDingTalk(url string) *DingTalk <span class="cov0" title="0">{
        return &amp;DingTalk{
                Url:       url,
                atMobiles: []string{},
                isAtAll:   false,
        }
}</span>

// @desc @部分成员
// @auth liuguoqiang 2020-12-07
// @param
// @return
func (dingTalk *DingTalk) WithAtMobiles(atMobiles []string) *DingTalk <span class="cov0" title="0">{
        if atMobiles != nil </span><span class="cov0" title="0">{
                dingTalk.atMobiles = atMobiles
        }</span>
        <span class="cov0" title="0">return dingTalk</span>
}

// @desc @所有成员
// @auth liuguoqiang 2020-12-07
// @param
// @return
func (dingTalk *DingTalk) WithIsAtAll(isAtAll bool) *DingTalk <span class="cov0" title="0">{
        dingTalk.isAtAll = isAtAll
        return dingTalk
}</span>

// @desc 发送钉钉消息
// @auth liuguoqiang 2020-12-07
// @param
// @return
func (dingTalk *DingTalk) SendMsg(body interface{}) ([]byte, error) <span class="cov0" title="0">{
        return Request(dingTalk.Url, body, nil)
}</span>

// @desc 发送钉钉文本消息
// @auth liuguoqiang 2020-12-07
// @param
// @return
func (dingTalk *DingTalk) SendTextMsg(content string) error <span class="cov0" title="0">{
        if dingTalk.Url == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("报警地址为空")
        }</span>
        <span class="cov0" title="0">msg := TextMsg{
                Msgtype: "text",
        }
        msg.Text.Content = content
        msg.At.IsAtAll = dingTalk.isAtAll
        msg.At.AtMobiles = dingTalk.atMobiles
        _, err := dingTalk.SendMsg(msg)
        return err</span>
}

// @desc Request 通用请求
// @auth liuguoqiang 2020-12-07
// @param
// @return
func Request(url string, body interface{}, headers map[string]string) ([]byte, error) <span class="cov0" title="0">{
        client := http_request.New()
        req := client.Request
        if headers != nil </span><span class="cov0" title="0">{
                req = req.SetHeaders(headers)
        }</span>
        <span class="cov0" title="0">response, err := req.
                SetBody(body).
                Post(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">respByte := response.Body()
        return respByte, err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package monitor

import (
        "context"
        "fmt"
        "sync"
        "time"
)

type Monitor struct {
        handlerList    []Handler
        closeWaitGroup *sync.WaitGroup
        closed         bool
}

type Handler interface {
        SendTextMsg(content string) error
}

// @desc
// @auth liuguoqiang 2020-12-07
// @param
// @return
func NewMonitor(handlerList ...Handler) *Monitor <span class="cov0" title="0">{
        return &amp;Monitor{
                handlerList:    handlerList,
                closeWaitGroup: &amp;sync.WaitGroup{},
                closed:         false,
        }
}</span>

// @desc 发送本消息
// @auth liuguoqiang 2020-12-07
// @param
// @return
func (monitor *Monitor) SendTextMsg(content string) error <span class="cov0" title="0">{
        if monitor.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("monitor closed")
        }</span>
        <span class="cov0" title="0">monitor.closeWaitGroup.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                fmt.Printf("%#v\n", r)
                        }</span>
                        <span class="cov0" title="0">monitor.closeWaitGroup.Done()</span>
                }()
                <span class="cov0" title="0">for k1 := range monitor.handlerList </span><span class="cov0" title="0">{
                        err := monitor.handlerList[k1].SendTextMsg(content)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("%#v\n", err)
                        }</span>
                }
        }()
        <span class="cov0" title="0">return nil</span>
}

// @desc 程序退出前阻塞直到将数据发送出去,或者超时
// @auth liuguoqiang 2020-12-07
// @param
// @return
func (monitor *Monitor) Close(timeout int64) <span class="cov0" title="0">{
        monitor.closed = true
        ctx, cancel := context.WithCancel(context.Background())
        go func(ctx context.Context) </span><span class="cov0" title="0">{
                monitor.closeWaitGroup.Wait()
                cancel()
        }</span>(ctx)

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                fmt.Println("monitor safe closed")
                return</span>
        case &lt;-time.After(time.Second * time.Duration(timeout)):<span class="cov0" title="0">
                fmt.Println("monitor timeout!!!")
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package sortx

//按照结构体中的某个字段排序
type Sort struct {
        Obj  interface{} `json:"obj"`
        Sort int64       `json:"sort"`
}
type SortList []Sort

func (list SortList) Len() int <span class="cov0" title="0">{
        return len(list)
}</span>

func (list SortList) Less(i, j int) bool <span class="cov0" title="0">{
        return list[i].Sort &lt;= list[j].Sort
}</span>

func (list SortList) Swap(i, j int) <span class="cov0" title="0">{
        temp := list[i]
        list[i] = list[j]
        list[j] = temp
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package sqlx

import (
        "fmt"
        "reflect"
        "strings"

        gorm "github.com/jinzhu/gorm"
)

var (
        FieldsError = fmt.Errorf("fileds length is 0")
)

// @desc
// @auth liuguoqiang 2020-11-27
// @param
// @return
func BulkInsert(db *gorm.DB, table string, fields []string, params []map[string]interface{}) error <span class="cov0" title="0">{
        if len(params) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(fields) == 0 </span><span class="cov0" title="0">{
                return FieldsError
        }</span>
        <span class="cov0" title="0">sql := "INSERT INTO `" + table + "` (`" + strings.Join(fields, "`,`") + "`) VALUES "
        args := make([]interface{}, 0)
        valueArr := make([]string, 0)
        varArr := make([]string, 0)
        for _, obj := range params </span><span class="cov0" title="0">{
                varArr = varArr[:0]
                varStr := "("
                for _, value := range fields </span><span class="cov0" title="0">{
                        if _, ok := obj[value]; !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s:not found in fields", value)
                        }</span>
                        <span class="cov0" title="0">varArr = append(varArr, "?")
                        args = append(args, obj[value])</span>
                }
                <span class="cov0" title="0">varStr += strings.Join(varArr, ",") + ")"
                valueArr = append(valueArr, varStr)</span>
        }
        <span class="cov0" title="0">sql += strings.Join(valueArr, ",")
        err := db.Exec(sql, args...).Error
        return err</span>
}

// @desc 批量插入
// @auth liuguoqiang 2020-11-27
// @param
// @return
func BulkSave(db *gorm.DB, table string, fields []string, params []map[string]interface{}) error <span class="cov0" title="0">{
        if len(params) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(fields) == 0 </span><span class="cov0" title="0">{
                return FieldsError
        }</span>
        <span class="cov0" title="0">sql := "INSERT INTO `" + table + "` (`" + strings.Join(fields, "`,`") + "`) VALUES "
        updateArr := make([]string, 0)
        args := make([]interface{}, 0)
        valueArr := make([]string, 0)
        varArr := make([]string, 0)
        for _, value := range fields </span><span class="cov0" title="0">{
                updateArr = append(updateArr, value+"=VALUES("+value+")")
        }</span>
        <span class="cov0" title="0">for _, obj := range params </span><span class="cov0" title="0">{
                varArr = varArr[:0]
                varStr := "("
                for _, value := range fields </span><span class="cov0" title="0">{
                        if _, ok := obj[value]; !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s字段在map中不存在", value)
                        }</span>
                        <span class="cov0" title="0">varArr = append(varArr, "?")
                        args = append(args, obj[value])</span>
                }
                <span class="cov0" title="0">varStr += strings.Join(varArr, ",") + ")"
                valueArr = append(valueArr, varStr)</span>
        }
        <span class="cov0" title="0">sql += strings.Join(valueArr, ",")
        sql += " ON DUPLICATE KEY UPDATE " + strings.Join(updateArr, ",")
        err := db.Exec(sql, args...).Error
        return err</span>
}

// @desc
// @auth liuguoqiang 2020-04-08
// @param
// @return
func Validate(data, model interface{}) bool <span class="cov0" title="0">{
        if _, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if reflect.TypeOf(data).Kind() == reflect.TypeOf(model).Kind() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package stringx

import (
        "fmt"
        "math/rand"
        "strconv"
        "time"
)

var (
        TimeLayout = "2006-01-02 15:04:05"
        ByteSeed   = []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890")
)

func ToString(param interface{}) (string, error) <span class="cov0" title="0">{
        resp := ""
        switch param.(type) </span>{
        case int64:<span class="cov0" title="0">
                resp = strconv.FormatInt(param.(int64), 10)</span>
        case int32:<span class="cov0" title="0">
                resp = strconv.FormatInt(param.(int64), 10)</span>
        case int:<span class="cov0" title="0">
                resp = strconv.Itoa(param.(int))</span>
        case float64:<span class="cov0" title="0">
                resp = strconv.FormatFloat(param.(float64), 'f', -1, 64)</span>
        case float32:<span class="cov0" title="0">
                resp = strconv.FormatFloat(param.(float64), 'f', -1, 64)</span>
        case string:<span class="cov0" title="0">
                resp = param.(string)</span>
        case []byte:<span class="cov0" title="0">
                resp = string(param.([]byte))</span>
        case time.Time:<span class="cov0" title="0">
                resp = param.(time.Time).Format(TimeLayout)</span>
        case *time.Time:<span class="cov0" title="0">
                resp = param.(*time.Time).Format(TimeLayout)</span>
        default:<span class="cov0" title="0">
                return resp, fmt.Errorf("%v is not base type", param)</span>
        }
        <span class="cov0" title="0">return resp, nil</span>
}

func SplitN(s string, n int) []string <span class="cov0" title="0">{
        len := len(s)
        var resp []string
        var index, next int

        for len &gt; index </span><span class="cov0" title="0">{
                next += n
                if len &gt;= next </span><span class="cov0" title="0">{
                        resp = append(resp, s[index:next])
                }</span> else<span class="cov0" title="0"> {
                        resp = append(resp, s[index:len])
                }</span>
                <span class="cov0" title="0">index = next</span>
        }
        <span class="cov0" title="0">return resp</span>
}

func ToStr(param interface{}) string <span class="cov0" title="0">{
        resp := ""
        switch param.(type) </span>{
        case int64:<span class="cov0" title="0">
                resp = strconv.FormatInt(param.(int64), 10)</span>
        case int32:<span class="cov0" title="0">
                resp = strconv.FormatInt(param.(int64), 10)</span>
        case int:<span class="cov0" title="0">
                resp = strconv.Itoa(param.(int))</span>
        case float64:<span class="cov0" title="0">
                resp = strconv.FormatFloat(param.(float64), 'f', -1, 64)</span>
        case float32:<span class="cov0" title="0">
                resp = strconv.FormatFloat(param.(float64), 'f', -1, 64)</span>
        case string:<span class="cov0" title="0">
                resp = param.(string)</span>
        case []byte:<span class="cov0" title="0">
                resp = string(param.([]byte))</span>
        case time.Time:<span class="cov0" title="0">
                resp = param.(time.Time).Format(TimeLayout)</span>
        case *time.Time:<span class="cov0" title="0">
                resp = param.(*time.Time).Format(TimeLayout)</span>
        default:<span class="cov0" title="0">
                return resp</span>
        }
        <span class="cov0" title="0">return resp</span>
}

func RandomString(len int) string <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
        resp := make([]byte, len)
        for i := 0; i &lt; len; i++ </span><span class="cov0" title="0">{
                resp[i] = ByteSeed[rand.Intn(62)]
        }</span>
        <span class="cov0" title="0">return string(resp)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package syncx

import "sync/atomic"

type AtomicBool uint32

func NewAtomicBool() *AtomicBool <span class="cov8" title="1">{
        return new(AtomicBool)
}</span>

func ForAtomicBool(val bool) *AtomicBool <span class="cov8" title="1">{
        b := NewAtomicBool()
        b.Set(val)
        return b
}</span>

func (b *AtomicBool) CompareAndSwap(old, val bool) bool <span class="cov8" title="1">{
        var ov, nv uint32
        if old </span><span class="cov8" title="1">{
                ov = 1
        }</span>
        <span class="cov8" title="1">if val </span><span class="cov8" title="1">{
                nv = 1
        }</span>
        <span class="cov8" title="1">return atomic.CompareAndSwapUint32((*uint32)(b), ov, nv)</span>
}

func (b *AtomicBool) Set(v bool) <span class="cov8" title="1">{
        if v </span><span class="cov8" title="1">{
                atomic.StoreUint32((*uint32)(b), 1)
        }</span> else<span class="cov8" title="1"> {
                atomic.StoreUint32((*uint32)(b), 0)
        }</span>
}

func (b *AtomicBool) True() bool <span class="cov8" title="1">{
        return atomic.LoadUint32((*uint32)(b)) == 1
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package syncx

import (
        "sync/atomic"
        "time"
)

type AtomicDuration int64

func NewAtomicDuration() *AtomicDuration <span class="cov8" title="1">{
        return new(AtomicDuration)
}</span>

func ForAtomicDuration(val time.Duration) *AtomicDuration <span class="cov8" title="1">{
        d := NewAtomicDuration()
        d.Set(val)
        return d
}</span>

func (d *AtomicDuration) CompareAndSwap(old, val time.Duration) bool <span class="cov8" title="1">{
        return atomic.CompareAndSwapInt64((*int64)(d), int64(old), int64(val))
}</span>

func (d *AtomicDuration) Load() time.Duration <span class="cov8" title="1">{
        return time.Duration(atomic.LoadInt64((*int64)(d)))
}</span>

func (d *AtomicDuration) Set(val time.Duration) <span class="cov8" title="1">{
        atomic.StoreInt64((*int64)(d), int64(val))
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package syncx

import (
        "math"
        "sync/atomic"
)

type AtomicFloat64 uint64

func NewAtomicFloat64() *AtomicFloat64 <span class="cov8" title="1">{
        return new(AtomicFloat64)
}</span>

func ForAtomicFloat64(val float64) *AtomicFloat64 <span class="cov8" title="1">{
        f := NewAtomicFloat64()
        f.Set(val)
        return f
}</span>

func (f *AtomicFloat64) Add(val float64) float64 <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                old := f.Load()
                nv := old + val
                if f.CompareAndSwap(old, nv) </span><span class="cov8" title="1">{
                        return nv
                }</span>
        }
}

func (f *AtomicFloat64) CompareAndSwap(old, val float64) bool <span class="cov8" title="1">{
        return atomic.CompareAndSwapUint64((*uint64)(f), math.Float64bits(old), math.Float64bits(val))
}</span>

func (f *AtomicFloat64) Load() float64 <span class="cov8" title="1">{
        return math.Float64frombits(atomic.LoadUint64((*uint64)(f)))
}</span>

func (f *AtomicFloat64) Set(val float64) <span class="cov8" title="1">{
        atomic.StoreUint64((*uint64)(f), math.Float64bits(val))
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package syncx

import (
        "sync"
        "sync/atomic"
)

const (
        maxDeleteCount = 10000
)

type (
        ConcurrentDoubleMap struct {
                cMap       []*ConcurrentMapShared
                length     int32
                shareCount int
        }
        ConcurrentMapShared struct {
                items        map[string]map[string]interface{}
                deleteCount  uint32
                sync.RWMutex // 各个分片Map各自的锁
        }
)

func NewConcurrentDoubleMap(shareCount int) *ConcurrentDoubleMap <span class="cov0" title="0">{
        if shareCount == 0 </span><span class="cov0" title="0">{
                shareCount = defaultShareCount
        }</span>
        <span class="cov0" title="0">m := make([]*ConcurrentMapShared, shareCount)
        for i := 0; i &lt; shareCount; i++ </span><span class="cov0" title="0">{
                m[i] = &amp;ConcurrentMapShared{
                        items: make(map[string]map[string]interface{}),
                }
        }</span>
        <span class="cov0" title="0">return &amp;ConcurrentDoubleMap{
                shareCount: shareCount,
                cMap:       m,
        }</span>
}

func (c *ConcurrentDoubleMap) GetShard(key string) *ConcurrentMapShared <span class="cov0" title="0">{
        return c.cMap[uint(fnv32(key))%uint(c.shareCount)]
}</span>

func (c *ConcurrentDoubleMap) Load(key1, key2 string) (interface{}, bool) <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        shard.RLock()
        defer shard.RUnlock()
        oldMap, ok := shard.items[key1]
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">value, ok := oldMap[key2]
        return value, ok</span>
}

func (c *ConcurrentDoubleMap) LoadMap(key1 string) (map[string]interface{}, bool) <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        shard.RLock()
        defer shard.RUnlock()
        oldMap, ok := shard.items[key1]
        return oldMap, ok
}</span>

func (c *ConcurrentDoubleMap) Store(key1, key2 string, value interface{}) <span class="cov0" title="0">{
        shard := c.GetShard(key1) // 段定位找到分片
        shard.Lock()
        oldMap, ok := shard.items[key1]
        if !ok </span><span class="cov0" title="0">{
                oldMap = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">_, ok = oldMap[key2]
        if !ok </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, 1)
        }</span>
        <span class="cov0" title="0">oldMap[key2] = value
        shard.items[key1] = oldMap
        shard.Unlock()</span>
}

func (c *ConcurrentDoubleMap) StoreWithPlugin(key1, key2 string, value interface{}, plugin func()) <span class="cov0" title="0">{
        shard := c.GetShard(key1) // 段定位找到分片
        shard.Lock()
        oldMap, ok := shard.items[key1]
        if !ok </span><span class="cov0" title="0">{
                oldMap = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">_, ok = oldMap[key2]
        if !ok </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, 1)
        }</span>
        <span class="cov0" title="0">oldMap[key2] = value
        shard.items[key1] = oldMap
        plugin()
        shard.Unlock()</span>
}

func (c *ConcurrentDoubleMap) LoadOrStore(key1, key2 string, value interface{}) (interface{}, bool) <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        shard.Lock()
        defer shard.Unlock()
        oldMap, loaded := shard.items[key1]
        if !loaded </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, 1)
                oldMap = make(map[string]interface{})
                oldMap[key2] = value
                shard.items[key1] = oldMap
                return value, loaded
        }</span>
        <span class="cov0" title="0">v, loaded := oldMap[key2]
        if !loaded </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, 1)
                oldMap[key2] = value
                shard.items[key1] = oldMap
                v = value
        }</span>
        <span class="cov0" title="0">return v, loaded</span>
}

// func (c *ConcurrentDoubleMap) Clear() {
//         for _, shard := range c.CMap {
//                 shard.Lock()
//                 for k := range shard.items {
//                         delete(shard.items, k)
//                 }
//                 shard.Unlock()
//         }
// }

// 统计当前分段map中item的个数
func (c *ConcurrentDoubleMap) Len() int32 <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;c.length)
}</span>

func (c *ConcurrentDoubleMap) Delete(key1, key2 string) <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        shard.Lock()
        defer shard.Unlock()
        if shard.delete(key1, key2) </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, -1)
        }</span>
}

func (c *ConcurrentDoubleMap) DeleteWithPlugin(key1, key2 string, plugin func()) <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        shard.Lock()
        defer shard.Unlock()
        if shard.delete(key1, key2) </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, -1)
        }</span>
        <span class="cov0" title="0">plugin()</span>
}

func (c *ConcurrentDoubleMap) DeleteWithoutLock(key1, key2 string) <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        if shard.delete(key1, key2) </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;c.length, -1)
        }</span>
}

func (c *ConcurrentDoubleMap) Range(f func(key1, key2 string, value interface{}) bool) bool <span class="cov0" title="0">{
        for _, shard := range c.cMap </span><span class="cov0" title="0">{
                shard.RLock()
                defer shard.RUnlock()
                for k1, oldMap := range shard.items </span><span class="cov0" title="0">{
                        for k2, v := range oldMap </span><span class="cov0" title="0">{
                                if !f(k1, k2, v) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return true</span>
}

func (c *ConcurrentDoubleMap) RangeNextMap(key1 string, f func(key1, key2 string, value interface{}) bool) bool <span class="cov0" title="0">{
        shard := c.GetShard(key1)
        shard.RLock()
        defer shard.RUnlock()
        oldMap, ok := shard.items[key1]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for k, v := range oldMap </span><span class="cov0" title="0">{
                if !f(key1, k, v) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (shard *ConcurrentMapShared) delete(key1, key2 string) bool <span class="cov0" title="0">{
        m1, ok := shard.items[key1]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">delete(m1, key2)
        shard.deleteCount++
        if len(m1) == 0 </span><span class="cov0" title="0">{
                delete(shard.items, key1)
        }</span>
        <span class="cov0" title="0">if shard.deleteCount &gt; maxDeleteCount </span><span class="cov0" title="0">{
                items := make(map[string]map[string]interface{})
                for k1 := range shard.items </span><span class="cov0" title="0">{
                        items[k1] = shard.items[k1]
                }</span>
                <span class="cov0" title="0">shard.items = items
                shard.deleteCount = 0</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package syncx

import (
        "sync"

        "github.com/weblazy/goutil"
)

type (
        ConcurrentMap struct {
                cMap       []goutil.Map // Add the len method to sync.Map to get the total number of elements
                shareCount int          // Number of shards
        }
)

const (
        defaultShareCount = 32 // Default number of shards
)

// NewConcurrentMap creates a new ConcurrentMap.
func NewConcurrentMap(shareCount int) *ConcurrentMap <span class="cov0" title="0">{
        if shareCount == 0 </span><span class="cov0" title="0">{
                shareCount = defaultShareCount
        }</span>
        <span class="cov0" title="0">m := make([]goutil.Map, shareCount)
        for i := 0; i &lt; shareCount; i++ </span><span class="cov0" title="0">{
                m[i] = goutil.AtomicMap()
        }</span>
        <span class="cov0" title="0">concurrentMap := &amp;ConcurrentMap{
                shareCount: shareCount,
                cMap:       m,
        }
        return concurrentMap</span>
}

// GetShard return a goutil.Map for a key
func (c *ConcurrentMap) GetShard(key string) goutil.Map <span class="cov0" title="0">{
        return c.cMap[uint(fnv32(key))%uint(c.shareCount)]
}</span>

// fnv32 FNV hash algorithm
func fnv32(key string) uint32 <span class="cov0" title="0">{
        hash := uint32(2166136261)
        const prime32 = uint32(16777619)
        for i := 0; i &lt; len(key); i++ </span><span class="cov0" title="0">{
                hash *= prime32
                hash ^= uint32(key[i])
        }</span>
        <span class="cov0" title="0">return hash</span>
}

// Load returns the value stored in the map for a key, or nil if no
// value is present.
// The ok result indicates whether value was found in the map.
func (c *ConcurrentMap) Load(key string) (interface{}, bool) <span class="cov0" title="0">{
        shard := c.GetShard(key)
        value, ok := shard.Load(key)
        return value, ok
}</span>

// Store sets the value for a key.
func (c *ConcurrentMap) Store(key string, value interface{}) <span class="cov0" title="0">{
        shard := c.GetShard(key)
        shard.Store(key, value)
}</span>

// LoadOrStore returns the existing value for the key if present.
// Otherwise, it stores and returns the given value.
// The loaded result is true if the value was loaded, false if stored.
func (c *ConcurrentMap) LoadOrStore(key string, value interface{}) (actual interface{}, loaded bool) <span class="cov0" title="0">{
        shard := c.GetShard(key)
        actual, loaded = shard.LoadOrStore(key, value)
        return actual, loaded
}</span>

// Clear clears all current data in the map.
func (c *ConcurrentMap) Clear() <span class="cov0" title="0">{
        for _, shard := range c.cMap </span><span class="cov0" title="0">{
                shard.Clear()
        }</span>
}

// Len get the total number of elements
func (c *ConcurrentMap) Len() int <span class="cov0" title="0">{
        count := 0
        for _, shard := range c.cMap </span><span class="cov0" title="0">{
                length := shard.Len()
                count += length
        }</span>
        <span class="cov0" title="0">return count</span>
}

// Keys Get all the keys
func (c *ConcurrentMap) Keys() []interface{} <span class="cov0" title="0">{
        count := c.Len()
        ch := make(chan interface{}, count)
        // Each shard initiates a coroutine traverse elements
        go func() </span><span class="cov0" title="0">{
                wg := sync.WaitGroup{}
                wg.Add(c.shareCount)
                for _, shard := range c.cMap </span><span class="cov0" title="0">{
                        go func(shard goutil.Map) </span><span class="cov0" title="0">{
                                shard.Range(func(k, v interface{}) bool </span><span class="cov0" title="0">{
                                        defer wg.Done()
                                        ch &lt;- k
                                        return true
                                }</span>)
                        }(shard)
                }
                <span class="cov0" title="0">wg.Wait()
                close(ch)</span>
        }()

        <span class="cov0" title="0">keys := make([]interface{}, count)
        // Collects the key of the map shard from each shard
        for k := range ch </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Values Get all the values
func (c *ConcurrentMap) Values() []interface{} <span class="cov0" title="0">{
        count := c.Len()
        ch := make(chan interface{}, count)
        // Each shard initiates a coroutine traverse elements
        go func() </span><span class="cov0" title="0">{
                wg := sync.WaitGroup{}
                wg.Add(c.shareCount)
                for _, shard := range c.cMap </span><span class="cov0" title="0">{
                        shard.Range(func(k, v interface{}) bool </span><span class="cov0" title="0">{
                                defer wg.Done()
                                ch &lt;- v
                                return true
                        }</span>)
                }
                <span class="cov0" title="0">wg.Wait()
                close(ch)</span>
        }()

        <span class="cov0" title="0">values := make([]interface{}, count)
        // Collects the key of the map shard from each shard
        for value := range ch </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return values</span>
}

// Delete deletes the value for a key.
func (c *ConcurrentMap) Delete(key string) <span class="cov0" title="0">{
        shard := c.GetShard(key)
        shard.Delete(key)
}</span>

// Range traverse elements
func (c *ConcurrentMap) Range(f func(key, value interface{}) bool) <span class="cov0" title="0">{
        for _, shard := range c.cMap </span><span class="cov0" title="0">{
                if !shard.Range(f) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package syncx

import (
        "time"

        "github.com/weblazy/easy/utils/timex"

        "github.com/weblazy/easy/utils/lang"
)

type Cond struct {
        signal chan lang.PlaceholderType
}

func NewCond() *Cond <span class="cov8" title="1">{
        return &amp;Cond{
                signal: make(chan lang.PlaceholderType),
        }
}</span>

// WaitWithTimeout wait for signal return remain wait time or timed out
func (cond *Cond) WaitWithTimeout(timeout time.Duration) (time.Duration, bool) <span class="cov8" title="1">{
        timer := time.NewTimer(timeout)
        defer timer.Stop()

        begin := timex.Now()
        select </span>{
        case &lt;-cond.signal:<span class="cov8" title="1">
                elapsed := timex.Since(begin)
                remainTimeout := timeout - elapsed
                return remainTimeout, true</span>
        case &lt;-timer.C:<span class="cov8" title="1">
                return 0, false</span>
        }
}

// Wait for signal
func (cond *Cond) Wait() <span class="cov8" title="1">{
        &lt;-cond.signal
}</span>

// Signal wakes one goroutine waiting on c, if there is any.
func (cond *Cond) Signal() <span class="cov8" title="1">{
        select </span>{
        case cond.signal &lt;- lang.Placeholder:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1"></span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package syncx

import (
        "sync"

        "github.com/weblazy/easy/utils/lang"
)

type DoneChan struct {
        done chan lang.PlaceholderType
        once sync.Once
}

func NewDoneChan() *DoneChan <span class="cov8" title="1">{
        return &amp;DoneChan{
                done: make(chan lang.PlaceholderType),
        }
}</span>

func (dc *DoneChan) Close() <span class="cov8" title="1">{
        dc.once.Do(func() </span><span class="cov8" title="1">{
                close(dc.done)
        }</span>)
}

func (dc *DoneChan) Done() chan lang.PlaceholderType <span class="cov8" title="1">{
        return dc.done
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package syncx

import (
        "errors"

        "github.com/weblazy/easy/utils/lang"
)

var ErrReturn = errors.New("discarding limited token, resource pool is full, someone returned multiple times")

type Limit struct {
        pool chan lang.PlaceholderType
}

func NewLimit(n int) Limit <span class="cov8" title="1">{
        return Limit{
                pool: make(chan lang.PlaceholderType, n),
        }
}</span>

func (l Limit) Borrow() <span class="cov8" title="1">{
        l.pool &lt;- lang.Placeholder
}</span>

// Return returns the borrowed resource, returns error only if returned more than borrowed.
func (l Limit) Return() error <span class="cov8" title="1">{
        select </span>{
        case &lt;-l.pool:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return ErrReturn</span>
        }
}

func (l Limit) TryBorrow() bool <span class="cov8" title="1">{
        select </span>{
        case l.pool &lt;- lang.Placeholder:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package syncx

import "sync"

type (
        // LockedCalls makes sure the calls with the same key to be called sequentially.
        // For example, A called F, before it's done, B called F, then B's call would not blocked,
        // after A's call finished, B's call got executed.
        // The calls with the same key are independent, not sharing the returned values.
        // A -------&gt;calls F with key and executes&lt;-------&gt;returns
        // B ------------------&gt;calls F with key&lt;---------&gt;executes&lt;----&gt;returns
        LockedCalls interface {
                Do(key string, fn func() (interface{}, error)) (interface{}, error)
        }

        lockedGroup struct {
                mu sync.Mutex
                m  map[string]*sync.WaitGroup
        }
)

func NewLockedCalls() LockedCalls <span class="cov8" title="1">{
        return &amp;lockedGroup{
                m: make(map[string]*sync.WaitGroup),
        }
}</span>

func (lg *lockedGroup) Do(key string, fn func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
</span>begin:
        <span class="cov8" title="1">lg.mu.Lock()
        if wg, ok := lg.m[key]; ok </span><span class="cov8" title="1">{
                lg.mu.Unlock()
                wg.Wait()
                goto begin</span>
        }

        <span class="cov8" title="1">return lg.makeCall(key, fn)</span>
}

func (lg *lockedGroup) makeCall(key string, fn func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        wg.Add(1)
        lg.m[key] = &amp;wg
        lg.mu.Unlock()

        defer func() </span><span class="cov8" title="1">{
                // delete key first, done later. can't reverse the order, because if reverse,
                // another Do call might wg.Wait() without get notified with wg.Done()
                lg.mu.Lock()
                delete(lg.m, key)
                lg.mu.Unlock()
                wg.Done()
        }</span>()

        <span class="cov8" title="1">return fn()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package syncx

import "sync"

type ManagedResource struct {
        resource interface{}
        lock     sync.RWMutex
        generate func() interface{}
        equals   func(a, b interface{}) bool
}

func NewManagedResource(generate func() interface{}, equals func(a, b interface{}) bool) *ManagedResource <span class="cov8" title="1">{
        return &amp;ManagedResource{
                generate: generate,
                equals:   equals,
        }
}</span>

func (mr *ManagedResource) MarkBroken(resource interface{}) <span class="cov8" title="1">{
        mr.lock.Lock()
        defer mr.lock.Unlock()

        if mr.equals(mr.resource, resource) </span><span class="cov8" title="1">{
                mr.resource = nil
        }</span>
}

func (mr *ManagedResource) Take() interface{} <span class="cov8" title="1">{
        mr.lock.RLock()
        resource := mr.resource
        mr.lock.RUnlock()

        if resource != nil </span><span class="cov8" title="1">{
                return resource
        }</span>

        <span class="cov8" title="1">mr.lock.Lock()
        defer mr.lock.Unlock()
        // maybe another Take() call already generated the resource.
        if mr.resource == nil </span><span class="cov8" title="1">{
                mr.resource = mr.generate()
        }</span>
        <span class="cov8" title="1">return mr.resource</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package syncx

import "sync"

func Once(fn func()) func() <span class="cov8" title="1">{
        once := new(sync.Once)
        return func() </span><span class="cov8" title="1">{
                once.Do(fn)
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package syncx

import "sync/atomic"

type OnceGuard struct {
        done uint32
}

func (og *OnceGuard) Taken() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;og.done) == 1
}</span>

func (og *OnceGuard) Take() bool <span class="cov8" title="1">{
        return atomic.CompareAndSwapUint32(&amp;og.done, 0, 1)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package syncx

import (
        "sync"
        "time"

        "github.com/weblazy/easy/utils/timex"
)

type (
        PoolOption func(*Pool)

        node struct {
                item     interface{}
                next     *node
                lastUsed time.Duration
        }

        Pool struct {
                limit   int
                created int
                maxAge  time.Duration
                lock    sync.Locker
                cond    *sync.Cond
                head    *node
                create  func() interface{}
                destroy func(interface{})
        }
)

func NewPool(n int, create func() interface{}, destroy func(interface{}), opts ...PoolOption) *Pool <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov8" title="1">{
                panic("pool size can't be negative or zero")</span>
        }

        <span class="cov8" title="1">lock := new(sync.Mutex)
        pool := &amp;Pool{
                limit:   n,
                lock:    lock,
                cond:    sync.NewCond(lock),
                create:  create,
                destroy: destroy,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(pool)
        }</span>

        <span class="cov8" title="1">return pool</span>
}

func (p *Pool) Get() interface{} <span class="cov8" title="1">{
        p.lock.Lock()
        defer p.lock.Unlock()

        for </span><span class="cov8" title="1">{
                if p.head != nil </span><span class="cov8" title="1">{
                        head := p.head
                        p.head = head.next
                        if p.maxAge &gt; 0 &amp;&amp; head.lastUsed+p.maxAge &lt; timex.Now() </span><span class="cov8" title="1">{
                                p.created--
                                p.destroy(head.item)
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                return head.item
                        }</span>
                }

                <span class="cov8" title="1">if p.created &lt; p.limit </span><span class="cov8" title="1">{
                        p.created++
                        return p.create()
                }</span>
                // 挂起当前协程,其他协程调用了 Signal 或 Broadcast 即唤醒该协程
                <span class="cov8" title="1">p.cond.Wait()</span>
        }
}

func (p *Pool) Put(x interface{}) <span class="cov8" title="1">{
        if x == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">p.lock.Lock()
        defer p.lock.Unlock()

        p.head = &amp;node{
                item:     x,
                next:     p.head,
                lastUsed: timex.Now(),
        }
        // 唤醒等待的协程
        p.cond.Signal()</span>
}

func WithMaxAge(duration time.Duration) PoolOption <span class="cov8" title="1">{
        return func(pool *Pool) </span><span class="cov8" title="1">{
                pool.maxAge = duration
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package syncx

import (
        "errors"
        "sync"
)

var ErrUseOfCleaned = errors.New("using a cleaned resource")

type RefResource struct {
        lock    sync.Mutex
        ref     int32
        cleaned bool
        clean   func()
}

func NewRefResource(clean func()) *RefResource <span class="cov8" title="1">{
        return &amp;RefResource{
                clean: clean,
        }
}</span>

func (r *RefResource) Use() error <span class="cov8" title="1">{
        r.lock.Lock()
        defer r.lock.Unlock()

        if r.cleaned </span><span class="cov8" title="1">{
                return ErrUseOfCleaned
        }</span>

        <span class="cov8" title="1">r.ref++
        return nil</span>
}

func (r *RefResource) Clean() <span class="cov8" title="1">{
        r.lock.Lock()
        defer r.lock.Unlock()

        if r.cleaned </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.ref--
        if r.ref == 0 </span><span class="cov8" title="1">{
                r.cleaned = true
                r.clean()
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package syncx

import (
        "io"
        "sync"

        "github.com/weblazy/easy/utils/errorx"
)

type ResourceManager struct {
        resources   map[string]io.Closer
        sharedCalls SharedCalls
        lock        sync.RWMutex
}

func NewResourceManager() *ResourceManager <span class="cov8" title="1">{
        return &amp;ResourceManager{
                resources:   make(map[string]io.Closer),
                sharedCalls: NewSharedCalls(),
        }
}</span>

func (manager *ResourceManager) Close() error <span class="cov8" title="1">{
        manager.lock.Lock()
        defer manager.lock.Unlock()

        var be errorx.BatchError
        for _, resource := range manager.resources </span><span class="cov8" title="1">{
                if err := resource.Close(); err != nil </span><span class="cov8" title="1">{
                        be = append(be, err)
                }</span>
        }

        <span class="cov8" title="1">return be</span>
}

func (manager *ResourceManager) GetResource(key string, create func() (io.Closer, error)) (io.Closer, error) <span class="cov8" title="1">{
        val, err := manager.sharedCalls.Do(key, func() (interface{}, error) </span><span class="cov8" title="1">{
                manager.lock.RLock()
                resource, ok := manager.resources[key]
                manager.lock.RUnlock()
                if ok </span><span class="cov8" title="1">{
                        return resource, nil
                }</span>

                <span class="cov8" title="1">resource, err := create()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">manager.lock.Lock()
                manager.resources[key] = resource
                manager.lock.Unlock()

                return resource, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return val.(io.Closer), nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package syncx

import "sync"

type (
        // SharedCalls lets the concurrent calls with the same key to share the call result.
        // For example, A called F, before it's done, B called F. Then B would not execute F,
        // and shared the result returned by F which called by A.
        // The calls with the same key are dependent, concurrent calls share the returned values.
        // A -------&gt;calls F with key&lt;-------------------&gt;returns val
        // B ---------------------&gt;calls F with key------&gt;returns val
        SharedCalls interface {
                Do(key string, fn func() (interface{}, error)) (interface{}, error)
                DoEx(key string, fn func() (interface{}, error)) (interface{}, bool, error)
        }

        call struct {
                wg  sync.WaitGroup
                val interface{}
                err error
        }

        sharedGroup struct {
                mu sync.Mutex
                m  map[string]*call
        }
)

func NewSharedCalls() SharedCalls <span class="cov8" title="1">{
        return &amp;sharedGroup{
                m: make(map[string]*call),
        }
}</span>

func (g *sharedGroup) Do(key string, fn func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        g.mu.Lock()
        if c, ok := g.m[key]; ok </span><span class="cov8" title="1">{
                g.mu.Unlock()
                c.wg.Wait()
                return c.val, c.err
        }</span>

        <span class="cov8" title="1">c := g.makeCall(key, fn)
        return c.val, c.err</span>
}

func (g *sharedGroup) DoEx(key string, fn func() (interface{}, error)) (val interface{}, fresh bool, err error) <span class="cov8" title="1">{
        g.mu.Lock()
        if c, ok := g.m[key]; ok </span><span class="cov8" title="1">{
                g.mu.Unlock()
                c.wg.Wait()
                return c.val, false, c.err
        }</span>

        <span class="cov8" title="1">c := g.makeCall(key, fn)
        return c.val, true, c.err</span>
}

func (g *sharedGroup) makeCall(key string, fn func() (interface{}, error)) *call <span class="cov8" title="1">{
        c := new(call)
        c.wg.Add(1)
        g.m[key] = c
        g.mu.Unlock()

        defer func() </span><span class="cov8" title="1">{
                // delete key first, done later. can't reverse the order, because if reverse,
                // another Do call might wg.Wait() without get notified with wg.Done()
                g.mu.Lock()
                delete(g.m, key)
                g.mu.Unlock()
                c.wg.Done()
        }</span>()

        <span class="cov8" title="1">c.val, c.err = fn()
        return c</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package syncx

import (
        "runtime"
        "sync/atomic"
)

type SpinLock struct {
        lock uint32
}

func (sl *SpinLock) Lock() <span class="cov8" title="1">{
        for !sl.TryLock() </span><span class="cov8" title="1">{
                runtime.Gosched()
        }</span>
}

func (sl *SpinLock) TryLock() bool <span class="cov8" title="1">{
        return atomic.CompareAndSwapUint32(&amp;sl.lock, 0, 1)
}</span>

func (sl *SpinLock) Unlock() <span class="cov8" title="1">{
        atomic.StoreUint32(&amp;sl.lock, 0)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package syncx

import (
        "errors"
        "time"
)

var ErrTimeout = errors.New("borrow timeout")

type TimeoutLimit struct {
        limit Limit
        cond  *Cond
}

func NewTimeoutLimit(n int) TimeoutLimit <span class="cov8" title="1">{
        return TimeoutLimit{
                limit: NewLimit(n),
                cond:  NewCond(),
        }
}</span>

func (l TimeoutLimit) Borrow(timeout time.Duration) error <span class="cov8" title="1">{
        if l.TryBorrow() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var ok bool
        for </span><span class="cov8" title="1">{
                timeout, ok = l.cond.WaitWithTimeout(timeout)
                if ok &amp;&amp; l.TryBorrow() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if timeout &lt;= 0 </span><span class="cov8" title="1">{
                        return ErrTimeout
                }</span>
        }
}

func (l TimeoutLimit) Return() error <span class="cov8" title="1">{
        if err := l.limit.Return(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">l.cond.Signal()
        return nil</span>
}

func (l TimeoutLimit) TryBorrow() bool <span class="cov8" title="1">{
        return l.limit.TryBorrow()
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// +build linux darwin

package system

import (
        "log"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"
)

const (
        wrapUpTime = time.Second
        // why we use 5500 milliseconds is because most of our queue are blocking mode with 5 seconds
        waitTime = 5500 * time.Millisecond
)

var (
        wrapUpListeners          = new(listenerManager)
        shutdownListeners        = new(listenerManager)
        delayTimeBeforeForceQuit = waitTime
)

func AddShutdownListener(fn func()) (waitForCalled func()) <span class="cov0" title="0">{
        return shutdownListeners.addListener(fn)
}</span>

func AddWrapUpListener(fn func()) (waitForCalled func()) <span class="cov0" title="0">{
        return wrapUpListeners.addListener(fn)
}</span>

func SetTimeoutToForceQuit(duration time.Duration) <span class="cov0" title="0">{
        delayTimeBeforeForceQuit = duration
}</span>

func gracefulStop(signals chan os.Signal) <span class="cov0" title="0">{
        signal.Stop(signals)

        log.Println("Got signal SIGTERM, shutting down...")
        wrapUpListeners.notifyListeners()

        time.Sleep(wrapUpTime)
        shutdownListeners.notifyListeners()

        time.Sleep(delayTimeBeforeForceQuit - wrapUpTime)
        log.Printf("Still alive after %v, going to force kill the process...\n", delayTimeBeforeForceQuit)
        syscall.Kill(syscall.Getpid(), syscall.SIGTERM)
}</span>

type listenerManager struct {
        lock      sync.Mutex
        waitGroup sync.WaitGroup
        listeners []func()
}

func (lm *listenerManager) addListener(fn func()) (waitForCalled func()) <span class="cov0" title="0">{
        lm.waitGroup.Add(1)

        lm.lock.Lock()
        lm.listeners = append(lm.listeners, func() </span><span class="cov0" title="0">{
                defer lm.waitGroup.Done()
                fn()
        }</span>)
        <span class="cov0" title="0">lm.lock.Unlock()

        return func() </span><span class="cov0" title="0">{
                lm.waitGroup.Wait()
        }</span>
}

func (lm *listenerManager) notifyListeners() <span class="cov0" title="0">{
        lm.lock.Lock()
        defer lm.lock.Unlock()

        for _, listener := range lm.listeners </span><span class="cov0" title="0">{
                listener()
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// +build linux darwin

package system

import (
        "log"
        "os"
        "os/signal"
        "syscall"
)

func init() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{

                // https://golang.org/pkg/os/signal/#Notify
                signals := make(chan os.Signal, 1)
                signal.Notify(signals, syscall.SIGUSR1, syscall.SIGUSR2, syscall.SIGTERM)

                for </span><span class="cov8" title="1">{
                        v := &lt;-signals
                        switch v </span>{
                        case syscall.SIGUSR1:<span class="cov0" title="0">
                                log.Println("syscall.SIGUSR1")</span>
                        case syscall.SIGUSR2:<span class="cov0" title="0">
                                log.Println("syscall.SIGUSR1")</span>
                        case syscall.SIGTERM:<span class="cov0" title="0">
                                gracefulStop(signals)</span>
                        default:<span class="cov0" title="0">
                                log.Println("Got unregistered signal:", v)</span>
                        }
                }
        }()
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package threading

import "github.com/weblazy/easy/utils/logx"

func Rescue(cleanups ...func()) <span class="cov8" title="1">{
        for _, cleanup := range cleanups </span><span class="cov8" title="1">{
                cleanup()
        }</span>

        <span class="cov8" title="1">if p := recover(); p != nil </span><span class="cov8" title="1">{
                logx.Stack(p)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package threading

import "sync"

type RoutineGroup struct {
        waitGroup sync.WaitGroup
}

func NewRoutineGroup() *RoutineGroup <span class="cov8" title="1">{
        return new(RoutineGroup)
}</span>

// Don't reference the variables from outside,
// because outside variables can be changed by other goroutines
func (g *RoutineGroup) Run(fn func()) <span class="cov8" title="1">{
        g.waitGroup.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer g.waitGroup.Done()
                fn()
        }</span>()
}

// Don't reference the variables from outside,
// because outside variables can be changed by other goroutines
func (g *RoutineGroup) RunSafe(fn func()) <span class="cov8" title="1">{
        g.waitGroup.Add(1)

        GoSafe(func() </span><span class="cov8" title="1">{
                defer g.waitGroup.Done()
                fn()
        }</span>)
}

func (g *RoutineGroup) Wait() <span class="cov8" title="1">{
        g.waitGroup.Wait()
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package threading

import (
        "bytes"
        "runtime"
        "strconv"
)

func GoSafe(fn func()) <span class="cov8" title="1">{
        go RunSafe(fn)
}</span>

// Only for debug, never use it in production
func RoutineId() uint64 <span class="cov8" title="1">{
        b := make([]byte, 64)
        b = b[:runtime.Stack(b, false)]
        b = bytes.TrimPrefix(b, []byte("goroutine "))
        b = b[:bytes.IndexByte(b, ' ')]
        // if error, just return 0
        n, _ := strconv.ParseUint(string(b), 10, 64)

        return n
}</span>

func RunSafe(fn func()) <span class="cov8" title="1">{
        defer Rescue()

        fn()
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package threading

import ()

type TaskRunner struct {
        limitChan chan struct{}
}

func NewTaskRunner(concurrency int) *TaskRunner <span class="cov8" title="1">{
        return &amp;TaskRunner{
                limitChan: make(chan struct{}, concurrency),
        }
}</span>

func (rp *TaskRunner) Schedule(task func()) <span class="cov8" title="1">{
        rp.limitChan &lt;- struct{}{}

        go func() </span><span class="cov8" title="1">{
                defer Rescue(func() </span><span class="cov8" title="1">{
                        &lt;-rp.limitChan
                }</span>)

                <span class="cov8" title="1">task()</span>
        }()
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package threading

import (
        "context"
        "time"
)

var (
        ErrCanceled = context.Canceled
        ErrTimeout  = context.DeadlineExceeded
)

type FxOption func() context.Context

func DoWithTimeout(fn func() error, timeout time.Duration, opts ...FxOption) error <span class="cov8" title="1">{
        parentCtx := context.Background()
        for _, opt := range opts </span><span class="cov8" title="1">{
                parentCtx = opt()
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(parentCtx, timeout)
        defer cancel()

        done := make(chan error)
        panicChan := make(chan interface{}, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if p := recover(); p != nil </span><span class="cov8" title="1">{
                                panicChan &lt;- p
                        }</span>
                }()
                <span class="cov8" title="1">done &lt;- fn()
                close(done)</span>
        }()

        <span class="cov8" title="1">select </span>{
        case p := &lt;-panicChan:<span class="cov8" title="1">
                panic(p)</span>
        case err := &lt;-done:<span class="cov8" title="1">
                return err</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        }
}

func WithContext(ctx context.Context) FxOption <span class="cov8" title="1">{
        return func() context.Context </span><span class="cov8" title="1">{
                return ctx
        }</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package timex

import "time"

// Use the long enough past time as start time, in case timex.Now() - lastTime equals 0.
var initTime = time.Now().AddDate(-1, -1, -1)

func Now() time.Duration <span class="cov8" title="1">{
        return time.Since(initTime)
}</span>

func Since(d time.Duration) time.Duration <span class="cov8" title="1">{
        return time.Since(initTime) - d
}</span>

func ToTime(d time.Duration) time.Time <span class="cov8" title="1">{
        return initTime.Add(d)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package timex

import (
        "errors"
        "time"

        "github.com/weblazy/easy/utils/lang"
)

type (
        Ticker interface {
                Chan() &lt;-chan time.Time
                Stop()
        }

        FakeTicker interface {
                Ticker
                Done()
                Tick()
                Wait(d time.Duration) error
        }

        fakeTicker struct {
                c    chan time.Time
                done chan lang.PlaceholderType
        }

        realTicker struct {
                *time.Ticker
        }
)

func NewRealTicker(d time.Duration) Ticker <span class="cov8" title="1">{
        return &amp;realTicker{
                Ticker: time.NewTicker(d),
        }
}</span>

func (rt *realTicker) Chan() &lt;-chan time.Time <span class="cov8" title="1">{
        return rt.C
}</span>

func NewFakeTicker() FakeTicker <span class="cov8" title="1">{
        return &amp;fakeTicker{
                c:    make(chan time.Time, 1),
                done: make(chan lang.PlaceholderType, 1),
        }
}</span>

func (ft *fakeTicker) Chan() &lt;-chan time.Time <span class="cov8" title="1">{
        return ft.c
}</span>

func (ft *fakeTicker) Done() <span class="cov8" title="1">{
        ft.done &lt;- lang.Placeholder
}</span>

func (ft *fakeTicker) Stop() <span class="cov8" title="1">{
        close(ft.c)
}</span>

func (ft *fakeTicker) Tick() <span class="cov8" title="1">{
        ft.c &lt;- ToTime(Now())
}</span>

func (ft *fakeTicker) Wait(d time.Duration) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-time.After(d):<span class="cov0" title="0">
                return errors.New("timeout")</span>
        case &lt;-ft.done:<span class="cov8" title="1">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package timex

import (
        "database/sql/driver"
        "time"
)

type Time time.Time

const (
        timeFormart = "2006-01-02 15:04:05"
)

func (t *Time) UnmarshalJSON(data []byte) (err error) <span class="cov0" title="0">{
        now, err := time.ParseInLocation(`"`+timeFormart+`"`, string(data), time.Local)
        *t = Time(now)
        return
}</span>

func (t Time) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b := make([]byte, 0, len(timeFormart)+2)
        b = append(b, '"')
        if !time.Time(t).IsZero() </span><span class="cov0" title="0">{
                b = time.Time(t).AppendFormat(b, timeFormart)
        }</span>
        <span class="cov0" title="0">b = append(b, '"')
        return b, nil</span>
}

func (t Time) String() string <span class="cov0" title="0">{
        return time.Time(t).Format(timeFormart)
}</span>

func (t Time) Value() (driver.Value, error) <span class="cov0" title="0">{
        if time.Time(t).IsZero() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return time.Time(t), nil</span>
}

func (t *Time) Scan(v interface{}) error <span class="cov0" title="0">{
        value, ok := v.(time.Time)
        if ok </span><span class="cov0" title="0">{
                *t = Time(value)
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package timex

import "time"

const (
        TimeLayout = "2006-01-02 15:04:05"
)

// @desc 获取某一天的0点时间
// @auth liuguoqiang 2020-04-27
// @param
// @return
func ZeroTime(d time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(d.Year(), d.Month(), d.Day(), 0, 0, 0, 0, time.Local)
}</span>

// @desc 返回一个月的开始时间和结束时间
// @auth liuguoqiang 2020-04-27
// @param
// @return
func MonthRange(timeStamp int64) (int64, int64) <span class="cov0" title="0">{
        d := time.Unix(timeStamp, 0)
        d = d.AddDate(0, 0, -d.Day()+1)
        start := ZeroTime(d)
        end := start.AddDate(0, 1, 0)
        return start.Unix(), end.Unix()
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package timingwheel

import (
        "fmt"
        "sync"
        "time"

        "github.com/tal-tech/go-zero/core/collection"
        "github.com/weblazy/easy/utils/list"
        "github.com/weblazy/easy/utils/threading"
        "github.com/weblazy/easy/utils/timex"
)

const (
        drainWorkers           = 8
        defaultMaxGoroutineNum = 16
)

type (
        // Execute defines the method to execute the task.
        Execute func(key, value interface{})

        // A TimingWheel is a timing wheel object to schedule tasks.
        TimingWheel struct {
                interval      time.Duration
                ticker        timex.Ticker
                slots         []map[int]*list.List
                timers        *collection.SafeMap
                tickedPos     int
                numSlots      int
                execute       Execute
                setChannel    chan timingEntry
                moveChannel   chan baseEntry
                removeChannel chan interface{}
                drainChannel  chan func(key, value interface{})
                stopChannel   chan struct{}

                cacheList       *list.List
                taskList        *list.List
                locked          bool
                lockCh          chan bool
                lock            sync.Mutex
                maxGoroutineNum int
                goroutineNum    int
                taskCh          chan *list.Element
        }

        timingEntry struct {
                baseEntry
                value  interface{}
                circle int
        }

        baseEntry struct {
                delay time.Duration
                key   interface{}
        }

        positionEntry struct {
                pos  int
                item *list.Element // item.Value -&gt;  *timingEntry
        }

        timingTask struct {
                key   interface{}
                value interface{}
        }
)

// NewTimingWheel returns a TimingWheel.
func NewTimingWheel(interval time.Duration, numSlots int, execute Execute) (*TimingWheel, error) <span class="cov8" title="1">{
        if interval &lt;= 0 || numSlots &lt;= 0 || execute == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("interval: %v, slots: %d, execute: %p", interval, numSlots, execute)
        }</span>

        <span class="cov8" title="1">return newTimingWheelWithClock(interval, numSlots, execute, timex.NewRealTicker(interval))</span>
}

func newTimingWheelWithClock(interval time.Duration, numSlots int, execute Execute, ticker timex.Ticker) (
        *TimingWheel, error) <span class="cov8" title="1">{
        tw := &amp;TimingWheel{
                interval:      interval,
                ticker:        ticker,
                slots:         make([]map[int]*list.List, numSlots),
                timers:        collection.NewSafeMap(),
                tickedPos:     numSlots - 1, // at previous virtual circle
                execute:       execute,
                numSlots:      numSlots,
                setChannel:    make(chan timingEntry),
                moveChannel:   make(chan baseEntry),
                removeChannel: make(chan interface{}),
                drainChannel:  make(chan func(key, value interface{})),
                stopChannel:   make(chan struct{}),

                cacheList:       list.New(),
                taskList:        list.New(),
                locked:          true,
                lockCh:          make(chan bool),
                taskCh:          make(chan *list.Element),
                maxGoroutineNum: defaultMaxGoroutineNum,
        }

        tw.initSlots()
        go tw.runTasks()
        go tw.run()

        return tw, nil
}</span>

// Drain drains all items and executes them.
func (tw *TimingWheel) Drain(fn func(key, value interface{})) <span class="cov0" title="0">{
        tw.drainChannel &lt;- fn
}</span>

// MoveTimer moves the task with the given key to the given delay.
func (tw *TimingWheel) MoveTimer(key interface{}, delay time.Duration) <span class="cov8" title="1">{
        if delay &lt;= 0 || key == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tw.moveChannel &lt;- baseEntry{
                delay: delay,
                key:   key,
        }</span>
}

// RemoveTimer removes the task with the given key.
func (tw *TimingWheel) RemoveTimer(key interface{}) <span class="cov8" title="1">{
        if key == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tw.removeChannel &lt;- key</span>
}

// SetTimer sets the task value with the given key to the delay.
func (tw *TimingWheel) SetTimer(key, value interface{}, delay time.Duration) <span class="cov8" title="1">{
        if delay &lt;= 0 || key == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tw.setChannel &lt;- timingEntry{
                baseEntry: baseEntry{
                        delay: delay,
                        key:   key,
                },
                value: value,
        }</span>
}

// Stop stops tw.
func (tw *TimingWheel) Stop() <span class="cov0" title="0">{
        close(tw.stopChannel)
}</span>

func (tw *TimingWheel) drainAll(fn func(key, value interface{})) <span class="cov0" title="0">{
        runner := threading.NewTaskRunner(drainWorkers)
        for k := range tw.slots </span><span class="cov0" title="0">{
                for k1 := range tw.slots[k] </span><span class="cov0" title="0">{
                        slot := tw.slots[k][k1]
                        for e := slot.Front(); e != nil; </span><span class="cov0" title="0">{
                                task := e.Value.(*timingEntry)
                                slot.Remove(e)
                                e = slot.Front()
                                runner.Schedule(func() </span><span class="cov0" title="0">{
                                        fn(task.key, task.value)
                                }</span>)
                        }
                }
                <span class="cov0" title="0">tw.slots[k] = make(map[int]*list.List)</span>
        }
}

func (tw *TimingWheel) getPositionAndCircle(d time.Duration) (pos, circle int) <span class="cov8" title="1">{
        steps := int(d / tw.interval)
        pos = (tw.tickedPos + steps) % tw.numSlots
        circle = (steps - 1) / tw.numSlots
        return
}</span>

func (tw *TimingWheel) initSlots() <span class="cov8" title="1">{
        for i := 0; i &lt; tw.numSlots; i++ </span><span class="cov8" title="1">{
                tw.slots[i] = make(map[int]*list.List)
        }</span>
}

func (tw *TimingWheel) moveTask(task baseEntry) <span class="cov8" title="1">{
        val, ok := tw.timers.Get(task.key)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">timer := val.(*positionEntry)
        item := timer.item.Value.(*timingEntry)
        // immediate execution
        if task.delay &lt; tw.interval </span><span class="cov0" title="0">{
                threading.GoSafe(func() </span><span class="cov0" title="0">{
                        tw.execute(item.key, item.value)
                }</span>)
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">pos, circle := tw.getPositionAndCircle(task.delay)
        // unchanged
        if pos == timer.pos &amp;&amp; circle == item.circle </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if _, ok := tw.slots[pos][circle]; !ok </span><span class="cov8" title="1">{
                tw.slots[pos][circle] = list.New()
        }</span>
        // remove old element
        <span class="cov8" title="1">tw.slots[timer.pos][item.circle].Remove(timer.item)

        item.circle = circle
        timer.pos = pos

        // push new element
        tw.slots[pos][circle].PushBack(item)
        timer.item = tw.slots[pos][circle].Back()</span>
}

func (tw *TimingWheel) onTick() <span class="cov0" title="0">{
        tw.tickedPos = (tw.tickedPos + 1) % tw.numSlots
        m := tw.slots[tw.tickedPos]
        if len(m) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">newM := make(map[int]*list.List)
        for k1 := range m </span><span class="cov0" title="0">{
                if k1 &gt; 0 </span><span class="cov0" title="0">{
                        newM[k1-1] = m[k1]
                }</span> else<span class="cov0" title="0"> {
                        for e := m[k1].Front(); e != nil; e = m[k1].Next(e) </span><span class="cov0" title="0">{
                                timingEntry := e.Value.(*timingEntry)
                                tw.timers.Del(timingEntry.key)
                        }</span>
                        <span class="cov0" title="0">tw.lock.Lock()
                        tw.cacheList.MergeBack(m[k1])
                        if tw.locked </span><span class="cov0" title="0">{
                                tw.locked = false
                                tw.lockCh &lt;- tw.locked
                        }</span>
                        <span class="cov0" title="0">tw.lock.Unlock()
                        m[k1].Init()</span>
                }
        }
        <span class="cov0" title="0">tw.slots[tw.tickedPos] = newM</span>
}

func (tw *TimingWheel) removeTask(key interface{}) <span class="cov8" title="1">{
        val, ok := tw.timers.Get(key)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">timer := val.(*positionEntry)
        item := timer.item.Value.(*timingEntry)
        tw.timers.Del(key)
        tw.slots[timer.pos][item.circle].Remove(timer.item)</span>
}

func (tw *TimingWheel) run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-tw.ticker.Chan():<span class="cov0" title="0">
                        tw.onTick()</span>
                case task := &lt;-tw.setChannel:<span class="cov8" title="1">
                        tw.setTask(&amp;task)</span>
                case key := &lt;-tw.removeChannel:<span class="cov8" title="1">
                        tw.removeTask(key)</span>
                case task := &lt;-tw.moveChannel:<span class="cov8" title="1">
                        tw.moveTask(task)</span>
                case fn := &lt;-tw.drainChannel:<span class="cov0" title="0">
                        tw.drainAll(fn)</span>
                case &lt;-tw.stopChannel:<span class="cov0" title="0">
                        tw.ticker.Stop()
                        return</span>
                }
        }
}

func (tw *TimingWheel) runTasks() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-tw.lockCh:<span class="cov0" title="0">
                        for </span><span class="cov0" title="0">{
                                e := tw.taskList.Back()
                                if e == nil </span><span class="cov0" title="0">{
                                        tw.lock.Lock()
                                        tw.taskList.MergeBack(tw.cacheList)
                                        tw.cacheList.Init()
                                        e = tw.taskList.Back()
                                        if e == nil </span><span class="cov0" title="0">{
                                                for tw.goroutineNum &gt; 0 </span><span class="cov0" title="0">{
                                                        tw.goroutineNum--
                                                        tw.taskCh &lt;- nil
                                                }</span>
                                                <span class="cov0" title="0">tw.locked = true
                                                tw.lock.Unlock()
                                                break</span>
                                        }
                                        <span class="cov0" title="0">tw.lock.Unlock()</span>
                                }
                                <span class="cov0" title="0">tw.taskList.Remove(e)
                                if tw.goroutineNum &lt; tw.maxGoroutineNum </span><span class="cov0" title="0">{
                                        tw.goroutineNum++
                                        go tw.worker()
                                }</span>
                                <span class="cov0" title="0">tw.taskCh &lt;- e</span>
                        }
                }
        }
}

func (tw *TimingWheel) worker() <span class="cov0" title="0">{
        for e := range tw.taskCh </span><span class="cov0" title="0">{
                if e == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">tw.execute(e.Value.(*timingEntry).key, e.Value.(*timingEntry).value)</span>
        }
}

func (tw *TimingWheel) setTask(task *timingEntry) <span class="cov8" title="1">{
        if task.delay &lt; tw.interval </span><span class="cov0" title="0">{
                task.delay = tw.interval
        }</span>

        <span class="cov8" title="1">if val, ok := tw.timers.Get(task.key); ok </span><span class="cov0" title="0">{
                entry := val.(*positionEntry)
                entry.item.Value.(*timingEntry).value = task.value
                tw.moveTask(task.baseEntry)
        }</span> else<span class="cov8" title="1"> {
                pos, circle := tw.getPositionAndCircle(task.delay)
                task.circle = circle
                if _, ok := tw.slots[pos][circle]; !ok </span><span class="cov8" title="1">{
                        tw.slots[pos][circle] = list.New()
                }</span>
                <span class="cov8" title="1">tw.slots[pos][circle].PushBack(task)
                tw.timers.Set(task.key, &amp;positionEntry{
                        pos:  pos,
                        item: tw.slots[pos][circle].Back(),
                })</span>
        }
}

func (tw *TimingWheel) GetValue(key string) (interface{}, bool) <span class="cov0" title="0">{
        val, ok := tw.timers.Get(key)
        if !ok </span><span class="cov0" title="0">{
                return nil, ok
        }</span>
        <span class="cov0" title="0">return val.(*positionEntry).item.Value, ok</span>
}

func (tw *TimingWheel) Len() int <span class="cov0" title="0">{
        return tw.timers.Size()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
